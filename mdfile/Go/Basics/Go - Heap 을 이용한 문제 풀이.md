## 시작
매일프로그래밍 이라는 곳에서 나왔던 문제를 풀어보자. <br />

문제) 정수 배열(int array)과 정수 N이 주어지면, N번째로 큰 배열 원소를 찾으시오.

예제) <br />
Input : [-1, 3, -1, 5, 4], 2 <br />
Output : 4 <br />


Input : [2, 4, -2, -3, 8], 1 <br />
Output : 8 <br />


Input : [-5, 3, 1], 3 <br />
Output : -5 <br />

이 문제를 푸는 방법은 여러가지가 있겠지만 <br />
Input : [-1, 3, -1, 5, 4], 2 <br />
Output : 4 <br />
의 경우 가장 무식하게, 단순하게 푸는 방법은 배열 2개 짜리를 하나 만들고, 가장 큰 값을 앞에, 두번째로 큰 값을 뒤에 적어주는 방법이다. <br />

|||
|------|---|

그래서 처음에 -1이 나왔고, 3이 있는데 3과 -1을 비교 했을 때 3이 크므로 3을 앞에 넣고, -1을 뒤에 넣는다. <br />

|3|-1|
|------|---|

그 다음 3과 -1은 같으니까 건너 뛰고, 5는 3보다 크므로 5를 앞에 넣고, 3을 뒤로 보낸다. <br />

|5|3|
|------|---|

그 다음 4는 5보다는 작고 3보다는 크므로 3이랑 바꾼다. <br />

|5|3|
|------|---|

그렇게 해서 4가 나오게 된다. 하지만 이 경우의 문제는 원소가 매우 큰 경우에 문제가 된다. 만약 1억개의 원소가 있고 이 중에서 2만 5천 번째 큰 수를 구하라고 했을 때 방금 풀었던 형태로 풀게 되면 <br />
2만 5천개의 배열이 있고, 1억개의 원소가 있을 때 2만 5천개의 배열은 큰 수 부터 2만 5천개가 정렬되어 있을 것이고, 2만 5천 1번째부터 그 수가 배열에 들어갈지 여부를 확인하려면 2만 5천개의 배열을 처음부터 끝까지 다 비교를 해야 한다. <br />
그 다음수도 마찬가지 일 것이다. 그 때 1억 * 2만 5천번의 for문을 돌려야 한다. <br />
이 때 N(배열의 갯수) * M(몇번째인지 나타내는 것)알고리즘이라고 한다. <br />
N과 M이 작으면 문제가 되지 않지만 크면 문제가 된다. <br />

두번째 방법은  <br />

Input : [-1, 3, -1, 5, 4], 2 <br />
Output : 4 <br />

이렇게 있을 때 위의 배열을 큰 수 부터 정렬을 시켜준다. <br />
그 다음에 2번째 수를 반환하는 것이다. <br />
이 방법의 속도를 알아보자. 정렬은 RADIX Sort와 Heap Sort방법이 있다고 말했는데 RADIX Sort는 가장 빠른 정렬방법이지만 일반적인 경우엔 사용할 수 없다. 물론 이 정렬이 RADIX Sort방법을 사용할 수 있으면 사용하면 되지만 일반적인 경우엔 사용할 수 없다. <br />

그래서 다른 정렬을 사용해야 하는데 Heap Sort, Quick Sort, Merge Sort, Insert Sort를 사용해야 하는데 모두 Nlog2^N이 든다. <br />
N은 배열의 갯수이고 log2^N만큼 속도가 필요하다. <br />
그래프로 설명하자면 아래와 같은데 <br />

<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/102330703-3bdb3780-3fcd-11eb-919b-3ff5bea3ab88.png" width = 70%> </img></p>

첫번째 파란색 그래프 mx라는 것은 첫번째 방법을 의미한다. 여기선 n대신 x를 넣었다. x가 늘어날 때 마다 속도가 비례해서 늘어난다.<br />
두번째 주황색 그래프는 정렬시킨 다음에 정렬된 배열에서 원하는 번째 수를 가져오는 방법이다. <br />
y축이 속도, x축이 항목 갯수인데 보게 되면 항목갯수가 늘어날 때 파란색 선이 더 빨리 끝나는 것을 알 수 있다. <br />

그런데 여기서 m의 값을 0.7이라고 가정한것인데 m을 1로 줘서 살펴보자. <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/102331110-bc019d00-3fcd-11eb-8252-eaa9a58e6868.png" width = 70%> </img></p>

항목이 2일 때는 서로 같지만 x가 늘어날 경우에 2번째 방법이 더 오래 걸리는 것을 알 수 있다. <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/102331212-e0f61000-3fcd-11eb-9026-2859026fea95.png" width = 70%> </img></p>

하지만 m이 늘어날 경우 m이 4라고 가정해보면 <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/102331307-0aaf3700-3fce-11eb-9cba-1dab30337c1b.png" width = 70%> </img></p> 
격차가 점점 줄어들다가 항목갯수가 16개 일 때 역전이 되는 것을 알 수 있다. <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/102331412-2c102300-3fce-11eb-9adc-1fd19bfe6825.png" width = 70%> </img></p> 

그러므로 일반적인 경우에 x\cdot\log_{2}\left(x\right)
