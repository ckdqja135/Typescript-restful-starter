# 변경사항

## 2020년 2월
 * 다음 파트들을 추가했습니다.
   * keyof <인터페이스(Interface)/인덱싱 가능 타입(Indexable Types)>
   * 타입 별칭(Type Aliases)
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 3월
 * 다음의 파트들을 추가했습니다.
   * 알 수 없는 타입(Unknown) <타입 기본(Types)/타입 선언>
   * 인터섹션(Intersection) <타입 기본(Types)/타입 선언>
   * 함수 타입 <인터페이스(Interface)>
   * 클래스 타입 <인터페이스(Interface)>
   * 인터페이스 확장 <인터페이스(Interface)>
   * 함수
   * this <함수>
   * 명시적 this <함수>
   * 오버로드(Overloads) <함수> 
 * 목차 흐름을 위해 ‘인덱스 시그니처(Index signature)’ 파트 제목을 삭제했습니다.(내용은 삭제하지 않았습니다)
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 4월
 * 다음의 파트들을 추가했습니다.
   * TS Node <개발환경>
   * 모듈
   * 내보내기(export)와 가져오기(import) <모듈>
   * 모듈의 타입 선언(Ambient module declaration) <모듈>
   * Definitely Typed(@types) <모듈>
   * typeRoots와 types 옵션 <모듈>
 * 컴파일 옵션에 대한 여러 링크를 추가했습니다.
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 6월
  * 다음의 파트들을 추가했습니다.
    * 제약 조건(Constraints) <제네릭(Generic)>
     * 조건부 타입(Conditional Types) <제네릭(Generic)>
     * infer <제네릭(Generic)>
     * Partial <TS 유틸리티 타입>
     * Required <TS 유틸리티 타입>
     * Readonly <TS 유틸리티 타입>
     * Record <TS 유틸리티 타입>
     * Pick <TS 유틸리티 타입>
     * Omit <TS 유틸리티 타입>
     * Exclude <TS 유틸리티 타입>
     * Extract <TS 유틸리티 타입>
     * NonNullable <TS 유틸리티 타입>
     * Parameters <TS 유틸리티 타입>
     * ConstructorParameters <TS 유틸리티 타입>
     * ReturnType <TS 유틸리티 타입>
     * InstanceType <TS 유틸리티 타입>
     * ThisParameterType <TS 유틸리티 타입>
     * OmitThisParameter <TS 유틸리티 타입>
     * ThisType <TS 유틸리티 타입>
   * ‘타입 가드’ 파트에 in 연산자에 대한 내용을 추가했습니다.
   * 일부 내용과 오타 등을 수정했습니다.
   
## 타입스크립트 개요

[타입스크립트(TypeScript)](https://www.typescriptlang.org/index.html)는 Microsoft에서 개발하고 유지/관리하는 [Apache 라이센스](https://ko.wikipedia.org/wiki/%EC%95%84%ED%8C%8C%EC%B9%98_%EB%9D%BC%EC%9D%B4%EC%84%A0%EC%8A%A4)가 부여된 오픈 소스입니다. <br />
일반 자바스크립트로 컴파일되는 자바스크립트 Superset(상위 호환)으로 2012년 10월에 처음 릴리스 되었습니다. <br />

## 왜 타입스크립트인가?

C#과 Java 같은 체계적이고 정제된 언어들에서 사용하는 강한 타입 시스템은 높은 가독성과 코드 품질 등을 제공할 수 있고 런타임이 아닌 컴파일 환경에서 에러가 발생해 치명적인 오류들을 더욱더 쉽게 잡아낼 수 있습니다. <br />

반면 자바스크립트는 타입 시스템이 없는 동적 프로그래밍 언어로, 자바스크립트 변수는 문자열, 숫자, 불린 등 여러 타입의 값을 가질 수 있습니다. <br />
이를 약한 타입 언어라고 표현할 수 있으며 비교적 유연하게 개발할 수 있는 환경을 제공하는 한편 런타임 환경에서 쉽게 에러가 발생할 수 있는 단점을 가집니다. <br />

그리고 타입스크립트는 이러한 자바스크립트에 강한 타입 시스템을 적용해 대부분의 에러를 컴파일 환경에서 코드를 입력하는 동안 체크할 수 있습니다. <br />

## 타입스크립트 사용법

자바스크립트가 <code>.js</code> 확장자를 가진 파일로 작성되는 것과 같이 타입스크립트는 .ts 확장자를 가진 파일로 작성할 수 있고, 작성 후 타입스크립트 컴파일러를 통해 자바스크립트 파일로 컴파일하여 사용하게 됩니다.

```typescript

  $ tsc sample.ts
  # compiled to `sample.js`

```

## 타입스크립트의 기능

* **크로스 플랫폼 지원**: 자바스크립트가 실행되는 모든 플랫폼에서 사용할 수 있습니다.
* **객체 지향 언어**: 클래스, 인터페이스, 모듈 등의 강력한 기능을 제공하며, 순수한 객체 지향 코드를 작성할 수 있습니다.
* **정적 타입**: 정적 타입을 사용하기 때문에 코드를 입력하는 동안에 오류를 체크할 수 있습니다.(단 에디터 혹은 플러그인의 도움의 필요)
* **DOM 제어**: 자바스크립트와 같이 DOM을 제어해 요소를 추가하거나 삭제할 수 있습니다.
* **최신 ECMAScript 기능 지원**: ES6 이상의 최신 자바스크립트 문법을 손쉽게 지원할 수 있습니다.

# 개발환경

## VSCode와 WebStorm

[VSCode(Visual Studio Code)](https://code.visualstudio.com/)와 (WebStorm)[https://www.jetbrains.com/ko-kr/webstorm/]은 타입스크립트 지원 기능이 내장되어 있기 때문에 별도의 설정 없이도 타입스크립트 파일을(<code>.ts, tsconfig.json</code> 등) 인식할 수 있고 코드 검사, 빠른 수정, 실행 및 디버깅 등의 다양한 기능을 바로 사용할 수 있습니다.
단, 컴파일러는 포함되어 있지 않기 때문에 별도로 설치해야 합니다.(E.g. <code>npm install typescript</code>)

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-vscode-error.jpg" width = 90%></img></p>
<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-webstorm-error.jpg" width = 90%></img></p>

## 컴파일러 설치

<code>tsc</code> 명령을 사용하기 위해 다음과 같이 타입스크립트를 전역 설치할 수 있습니다. <br />
타입스크립트 파일을 경로로 지정하면 해당 파일을 컴파일합니다. <br />

```typescript

  $ npm install -g typescript
  $ tsc --version
  $ tsc ./src/index.ts

```

혹은, 단일 프로젝트에서만 사용하길 희망하는 경우 일반 지역 설치 후 <code>npx tsc</code> 명령으로 실행할 수도 있습니다.

```typescript

  $ npm install -D typescript
  $ npx tsc --version 
  $ npx tsc ./src/index.ts

```

## 컴파일러 옵션

타입스크립트 (컴파일을 위한 다양한 옵션)[https://www.typescriptlang.org/docs/handbook/compiler-options.html을 지정할 수 있습니다.

* 공식 문서: https://www.typescriptlang.org/docs/handbook/compiler-options.html
* 공식 문서 한글 번역: https://typescript-kr.github.io/pages/Compiler%20Options.html
* vomvoru’s blog: https://vomvoru.github.io/blog/tsconfig-compiler-options-kr/

```typescpript

  $ tsc ./src/index.ts --watch --strict true --target ES6 --lib ES2015,DOM --module CommonJS
  
```

> VScode와 WebStorm을 사용하는 경우, tsconfig.json 파일을 프로젝트 루트 경로에 생성하면 에디터에 의해 구성 옵션이 분석됩니다.

```typescript

  {
    "compilerOptions": {
      "strict": true,
      "target": "ES6",
      "lib": ["ES2015", "DOM"],
      "module": "CommonJS"
    },
    "include": [
      "src/**/*.ts"
    ],
    "exclude": [
      "node_modules"
    ]
  }

```

```typescript

  $ tsc --watch
  
```

## TypeScript Playground

https://www.typescriptlang.org/play/index.html

타입스크립트 공식 페이지에서 제공하는 REPL로, 작성한 내용이 컴파일러 옵션에 따라 어떻게 자바스크립트로 변환되는지 바로 확인할 수 있습니다.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-playground.jpg" width = 90%></img></p>

## Repl.it

https://repl.it/languages/typescript

파일과 디렉터리로 관리되는 타입스크립트 프로젝트를 손쉽게 구성할 수 있습니다. <br />
간단한 프로젝트로 타입스크립트를 테스트하기 좋습니다. <br />

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-repl.jpg" width = 90%></img></p>

## Parcel

타입스크립트를 로컬 환경에서 빠르게 테스트하고 싶다면 [Parcel 번들러](https://ko.parceljs.org/getting_started.html)가 좋은 선택입니다. <br />
다음과 같이 간단하게 프로젝트를 구성합니다. <br />

```typescript
  
  $ mkdir typescript-test
  $ cd typescript-test
  $ npm init -y
  $ npm install -D typescript parcel-bundler

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-test-with-parcel-bundler.jpg" width = 90%></img></p>

<code>tsconfig.json</code> 파일을 생성하고 원하는 옵션을 추가합니다. <br />
다음은 예시입니다. <br />

```typescript

  {
    "compilerOptions": {
      "strict": true
    },
    "exclude": [
      "node_modules"
    ]
  }

```

<code>main.ts</code> 파일을 생성하고 원하는 타입스크립트 코드를 입력합니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  
  const sum: number = add(1, 2);
  console.log(sum);

```

<code>index.html</code> 파일을 생성하고 다음과 같이 <code>.js</code>가 아닌 <code>.ts</code> 파일을 연결합니다. <br />
Parcel 번들러가 빌드시 자동으로 타입스크립트를 컴파일합니다. <br />

```HTML

  <!doctype html>
  <html>
  <head>
    <meta charset="UTF-8">
    <title>TypeScript Test</title>
  </head>
  <body>
    <script src="main.ts"></script>
  </body>
  </html>

```

마지막으로 다음과 같이 진입 파일로 <code>index.html</code>를 지정하고 Parcel 번들러로 빌드합니다.

```typescript

  $ npx parcel index.html
  # Server running at http://localhost:1234

```

## TS Node

NodeJS 환경에서 테스트하고 싶다면 [TS Node](https://github.com/TypeStrong/ts-node)를 사용하세요. <br />
다음과 같이 간단하게 프로젝트를 구성합니다. <Br />

```text

  $ mkdir typescript-test
  $ cd typescript-test
  $ npm init -y
  $ npm install -D typescript @types/node ts-node

```

> [@types/node](https://github.com/DefinitelyTyped/DefinitelyTyped)는 Node.js API를 위한 타입 선언 모듈입니다.
> **@types**에 대한 자세한 내용은 ‘모듈’ 파트를 참고하세요.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-test-with-ts-node.jpg" width = 90%></img></p>

<code>tsconfig.json</code> 파일을 생성하고 원하는 옵션을 추가합니다. <br />
다음은 예시입니다. <br />

```json

  {
    "compilerOptions": {
      "strict": true,
      "module": "CommonJS"
    },
    "exclude": [
      "node_modules"
    ]
  }

```

<code>main.ts</code> 파일을 생성하고 원하는 타입스크립트 코드를 입력합니다.

```typescript

  console.log('TypeScript on NodeJS!');
  
```

TS Node를 사용해 <code>main.ts</code>를 실행합니다.

```typescript
  
  $ npx ts-node main.js
  # TypeScript on NodeJS!

```

# 타입 기본(Types)

## 타입 지정

타입스크립트는 일반 변수, 매개 변수(Parameter), 객체 속성(Property) 등에 : TYPE과 같은 형태로 타입을 지정할 수 있습니다.

```typescript

  function someFunc(a: TYPE_A, b: TYPE_B): TYPE_RETURN {
    return a + b;
  }
  let some: TYPE_SOME = someFunc(1, 2);
  
```

다음 예시를 보면,
<code>add</code> 함수의 매개 변수 <code>a</code>와 <code>b</code>는 <code>number</code> 타입이어야 한다고 지정했고,
그렇게 실행된 함수의 반환 값은 숫자로 추론(Inference)되기 때문에 변수 <code>sum</code>도 <code>number</code> 타입이어야 한다고 지정했습니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  const sum: number = add(1, 2);
  console.log(sum); // 3

```

자바스크립트로 컴파일한 결과는 다음과 같습니다.

```typescript

  "use strict";
  function add(a, b) {
    return a + b;
  }
  const sum = add(1, 2);
  console.log(sum);

```

## 타입 에러

만약 다음과 같이 변수 <code>sum</code>을 <code>number</code>가 아닌 <code>string</code> 타입이어야 한다고 지정했다면, 컴파일조차 하지 않고 코드를 작성하는 시점에서 에러가 발생합니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  const sum: string = add(1, 2);
  console.log(sum);

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-error-ts2322.jpg" width = 90%></img></p>

위 이미지에서 [TS2322](https://www.google.com/search?newwindow=1&sxsrf=ACYBGNQeWU6z1K7DXQ9oM0VR4gV-KPSd2Q%3A1580379601357&ei=0a0yXpuyFZyCr7wPi96owAU&q=TS2322&oq=TS2322&gs_l=psy-ab.3..35i39j0j0i203l4j0j0i203l3.15216190.15216190..15216895...0.0..0.114.321.1j2......0....2j1..gws-wiz.......0i67j0i7i30j0i7i10i30j0i5i30j0i5i10i30.1W9DJiS_O3c&ved=0ahUKEwjb3v7ljKvnAhUcwYsBHQsvClgQ4dUDCAs&uact=5)라는 에러 코드를 볼 수 있으며, 이를 검색하면 쉽게 에러 코드에 대한 정보를 얻을 수 있습니다.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/search-typescript-error-code.jpg" width = 90%></img></p>

## 타입 선언

## 불린: Boolean

단순한 참(<code>true</code>)/거짓(<code>false</code>) 값을 나타냅니다.

```typescript

  let isBoolean: boolean;
  let isDone: boolean = false;

```

## 숫자: Number

모든 부동 소수점 값을 사용할 수 있습니다. <br />
ES6에 도입된 2진수 및 8진수 리터럴도 지원합니다. <br />

```typescript

  let num: number;
  let integer: number = 6;
  let float: number = 3.14;
  let hex: number = 0xf00d; // 61453
  let binary: number = 0b1010; // 10
  let octal: number = 0o744; // 484
  let infinity: number = Infinity;
  let nan: number = NaN;

```

## 문자열: String

문자열을 나타냅니다.
작은따옴표(<code>'</code>), 큰따옴표(<code>"</code>) 뿐만 아니라 ES6의 템플릿 문자열도 지원합니다.

```typescript
  
  let str: string;
  let red: string = 'Red';
  let green: string = "Green";
  let myColor: string = `My color is ${red}.`;
  let yourColor: string = 'Your color is' + green;

```

## 배열: Array

순차적으로 값을 가지는 일반 배열을 나타냅니다. <br />
배열은 다음과 같이 두 가지 방법으로 타입을 선언할 수 있습니다. <Br />


```typescript

  // 문자열만 가지는 배열
  let fruits: string[] = ['Apple', 'Banana', 'Mango'];
  // Or
  let fruits: Array<string> = ['Apple', 'Banana', 'Mango'];

  // 숫자만 가지는 배열
  let oneToSeven: number[] = [1, 2, 3, 4, 5, 6, 7];
  // Or
  let oneToSeven: Array<number> = [1, 2, 3, 4, 5, 6, 7];

```

유니언 타입(다중 타입)의 ‘문자열과 숫자를 동시에 가지는 배열’도 선언할 수 있습니다.

```typescript
  
  let array: (string | number)[] = ['Apple', 1, 2, 'Banana', 'Mango', 3];
  // Or
  let array: Array<string | number> = ['Apple', 1, 2, 'Banana', 'Mango', 3];

```

배열이 가지는 항목의 값을 단언할 수 없다면 <code>any</code>를 사용할 수 있습니다.

```typescript
  
  let someArr: any[] = [0, 1, {}, [], 'str', false];
  
```

인터페이스(Interface)나 커스텀 타입(Type)을 사용할 수도 있습니다.

```typescript

  interface IUser {
    name: string,
    age: number,
    isValid: boolean
  }
  let userArr: IUser[] = [
    {
      name: 'Neo',
      age: 85,
      isValid: true
    },
    {
      name: 'Lewis',
      age: 52,
      isValid: false
    },
    {
      name: 'Evan',
      age: 36,
      isValid: true
    }
  ];

```

유용하진 않지만, 다음과 같이 특정한 값으로 타입을 대신해 작성할 수도 있습니다.

```typescript

  let array = 10[];
  array = [10];
  array.push(10);
  array.push(11); // Error - TS2345

```

읽기 전용 배열을 생성할 수도 있습니다. <br />
<code>readonly</code> 키워드나 <code>ReadonlyArray</code> 타입을 사용하면 됩니다.

```typescript

  let arrA: readonly number[] = [1, 2, 3, 4];
  let arrB: ReadonlyArray<number> = [0, 9, 8, 7];

  arrA[0] = 123; // Error - TS2542: Index signature in type 'readonly number[]' only permits reading.
  arrA.push(123); // Error - TS2339: Property 'push' does not exist on type 'readonly number[]'.

  arrB[0] = 123; // Error - TS2542: Index signature in type 'readonly number[]' only permits reading.
  arrB.push(123); // Error - TS2339: Property 'push' does not exist on type 'readonly number[]'.

```

## 튜플: Tuple

Tuple 타입은 배열과 매우 유사합니다.
차이점이라면 **정해진 타입의 고정된 길이(length) 배열**을 표현합니다.

```typescript

  let tuple: [string, number];
  tuple = ['a', 1];
  tuple = ['a', 1, 2]; // Error - TS2322
  tuple = [1, 'a']; // Error - TS2322

```

다음과 같이 데이터를 개별 변수로 지정하지 않고, 단일 Tuple 타입으로 지정해 사용할 수 있습니다.

```typescript

  // Variables
  let userId: number = 1234;
  let userName: string = 'HEROPY';
  let isValid: boolean = true;

  // Tuple
  let user: [number, string, boolean] = [1234, 'HEROPY', true];
  console.log(user[0]); // 1234
  console.log(user[1]); // 'HEROPY'
  console.log(user[2]); // true

```

나아가 위 방식을 활용해 다음과 같은 Tuple 타입의 배열(2차원 배열)을 사용할 수 있습니다.

```typescript
  
  let users: [number, string, boolean][];
  // Or
  // let users: Array<[number, string, boolean]>;

  users = [[1, 'Neo', true], [2, 'Evan', false], [3, 'Lewis', true]];

```

역시 값으로 타입을 대신할 수도 있습니다.

```typescript

  let tuple: [1, number];
  tuple = [1, 2];
  tuple = [1, 3];
  tuple = [2, 3]; // Error - TS2322: Type '2' is not assignable to type '1'.

```

Tuple은 **정해진 타입의 고정된 길이 배열**을 표현하지만, 이는 할당(Assign)에 국한됩니다. <br />
<code>.push()</code>나 <code>.splice()</code> 등을 통해 값을 넣는 행위는 막을 수 없습니다. <br />

```typescript

  let tuple: [string, number];
  tuple = ['a', 1];
  tuple = ['b', 2];
  tuple.push(3);
  console.log(tuple); // ['b', 2, 3];
  tuple.push(true); // Error - TS2345: Argument of type 'true' is not assignable to parameter of type 'string | number'.

```

배열에서 사용한 것과 같이 <code>readonly</code> 키워드를 사용해 읽기 전용 튜플을 생성할 수도 있습니다.

```typescript

  let a: readonly [string, number] = ['Hello', 123];
  a[0] = 'World'; // Error - TS2540: Cannot assign to '0' because it is a read-only property.

```

## 열거형: Enum

Enum은 숫자 혹은 문자열 값 집합에 이름(Member)을 부여할 수 있는 타입으로, 값의 종류가 일정한 범위로 정해져 있는 경우 유용합니다. <Br />

기본적으로 <code>0</code>부터 시작하며 값은 <code>1</code>씩 증가합니다. <br />

```typescript
  
  enum Week {
    Sun,
    Mon,
    Tue,
    Wed,
    Thu,
    Fri,
    Sat
  }

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-enum-example1.jpg" width = 90%></img></p>

수동으로 값을 변경할 수 있으며, 값을 변경한 부분부터 다시 <code>1</code>씩 증가합니다.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-enum-example2.jpg" width = 90%></img></p>

Enum 타입의 재미있는 부분은 역방향 매핑(Reverse Mapping)을 지원한다는 것입니다. <br />
이것은 열거된 멤버(<code>Sun</code>, <code>Mon</code> 같은)로 값에, 값으로 멤버에 접근할 수 있다는 것을 의미합니다. <br />

<code>Week</code>를 콘솔로 출력합니다.

```typescript

  enum Week {
    // ...
  }
  console.log(Week);
  console.log(Week.Sun); // 0
  console.log(Week['Sun']); // 0
  console.log(Week[0]); // 'Sun'

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-enum-console-log.jpg" width = 90%></img></p>

추가로, Enum은 숫자 값 열거뿐만아니라 다음과 같이 문자열 값으로 초기화할 수 있습니다. <br /> 
이 방법은 역방향 매핑(Reverse Mapping)을 지원하지 않으며 개별적으로 초기화해야 하는 단점이 있습니다. <br />

```typescript

  enum Color {
    Red = 'red',
    Green = 'green',
    Blue = 'blue'
  }
  console.log(Color.Red); // red
  console.log(Color['Green']); // green

```

## 모든 타입: Any

Any는 모든 타입을 의미합니다. <br />
따라서 일반적인 자바스크립트 변수와 동일하게 어떤 타입의 값도 할당할 수 있습니다. <br />
외부 자원을 활용해 개발할 때 불가피하게 타입을 단언할 수 없는 경우, 유용할 수 있습니다. <br />

```typescript

  let any: any = 123;
  any = 'Hello world';
  any = {};
  any = null;

```

다양한 값을 포함하는 배열을 나타낼 때 사용할 수도 있습니다.

```typescript

  const list: any[] = [1, true, 'Anything!'];
  
```

강한 타입 시스템의 장점을 유지하기 위해 Any 사용을 엄격하게 금지하려면, 컴파일 옵션 "noImplicitAny": true를 통해 Any 사용 시 에러를 발생시킬 수 있습니다.

## 알 수 없는 타입: Unknown

Any와 같이 최상위 타입인 Unknown은 알 수 없는 타입을 의미합니다. <br />
Any와 같이 Unknown에는 어떤 타입의 값도 할당할 수 있지만, Unknown을 다른 타입에는 할당할 수 없습니다. <br />

> 일반적인 경우 Unknown은 타입 단언(Assertions)이나 타입 가드(Guards)를 필요로 합니다. <Br/ >
> 타입 단언이나 가드에 대한 내용은 다른 파트에서 정리합니다.

```typescript

  let a: any = 123;
  let u: unknown = 123;

  let v1: boolean = a; // 모든 타입(any)은 어디든 할당할 수 있습니다.
  let v2: number = u; // 알 수 없는 타입(unknown)은 모든 타입(any)을 제외한 다른 타입에 할당할 수 없습니다.
  let v3: any = u; // OK!
  let v4: number = u as number; // 타입을 단언하면 할당할 수 있습니다.

```

다양한 타입을 반환할 수 있는 API에서 유용할 수 있습니다.

> Unknown 보단 좀 더 명확한 타입을 사용하는 것이 좋습니다.

```typescript

  type Result = {
    success: true,
    value: unknown
  } | {
    success: false,
    error: Error
  }

  export default function getItems(user: IUser): Result {
    // Some logic...
    if (id.isValid) {
      return {
        success: true,
        value: ['Apple', 'Banana']
      };
    } else {
      return {
        success: false,
        error: new Error('Invalid user.')
      }
    }
  }

```

## 객체: Object

기본적으로 <code>typeof</code> 연산자가 <code>"object"</code>로 반환하는 모든 타입을 나타냅니다.

> 컴파일러 옵션에서 엄격한 타입 검사(<code>strict</code>)를 <code>true</code>로 설정하면, <code>null</code>은 포함하지 않습니다.

```typescript

  let obj: object = {};
  let arr: object = [];
  let func: object = function () {};
  let nullValue: object = null;
  let date: object = new Date();
  // ...

```

여러 타입의 상위 타입이기 때문에 그다지 유용하지 않습니다. <br />
보다 정확하게 타입 지정을 하기 위해 다음과 같이 객체 속성(Properties)들에 대한 타입을 개별적으로 지정할 수 있습니다. <br />

```typescript

  let userA: { name: string, age: number } = {
    name: 'HEROPY',
    age: 123
  };

  let userB: { name: string, age: number } = {
    name: 'HEROPY',
    age: false, // Error
    email: 'thesecon@gmail.com' // Error
  };

```

반복적인 사용을 원하는 경우, <code>interface</code>나 <code>type</code>을 사용하는 것을 추천합니다.

```typescript

  interface IUser {
    name: string,
    age: number
  }

  let userA: IUser = {
    name: 'HEROPY',
    age: 123
  };

  let userB: IUser = {
    name: 'HEROPY',
    age: false, // Error
    email: 'thesecon@gmail.com' // Error
  };

```

## Null과 Undefined

기본적으로 Null과 Undefined는 모든 타입의 하위 타입으로, 다음과 같이 각 타입에 할당할 수 있습니다. <Br />
심지어 서로의 타입에도 할당 가능합니다. <br />

```typescript

  let num: number = undefined;
  let str: string = null;
  let obj: { a: 1, b: false } = undefined;
  let arr: any[] = null;
  let und: undefined = null;
  let nul: null = undefined;
  let voi: void = null;
  // ...

```

이는 컴파일 옵션 <code>"strictNullChecks": true</code>을 통해 엄격하게 Null과 Undefined 서로의 타입까지 더 이상 할당할 수 없게 합니다.
단, Void에는 Undefined를 할당할 수 있습니다.

```typescript

  let voi: void = undefined; // ok  

```

## Void

Void는 일반적으로 값을 반환하지 않는 함수에서 사용합니다. <br />
<code>: void</code> 위치는 함수가 반환 타입을 명시하는 곳입니다. <br />

```typesript

  function hello(msg: string): void {
    console.log(`Hello ${msg}`);
  }

```

값을 반환하지 않는 함수는 실제로는 <code>undefined</code>를 반환합니다.


```typescript

  function hello(msg: string): void {
    console.log(`Hello ${msg}`);
  }
  const hi: void = hello('world'); // Hello world
  console.log(hi); // undefined

```

```typescript

  // Error - TS2355: A function whose declared type is neither 'void' nor 'any' must return a value.
  function hello(msg: string): undefined {
    console.log(`Hello ${msg}`);
  }

```

## Never

Never은 **절대 발생하지 않을 값**을 나타내며, 어떠한 타입도 적용할 수 없습니다.

```typescript

   function error(message: string): never {
      throw new Error(message);
  }

```

보통 다음과 같이 빈 배열을 타입으로 잘못 선언한 경우, Never를 볼 수 있습니다.

```typescript

  const never: [] = [];
  never.push(3); // Error - TS2345: Argument of type '3' is not assignable to parameter of type 'never'.

```

## 유니언(Union)

2개 이상의 타입을 허용하는 경우, 이를 유니언(Union)이라고 합니다. <br />
<code>|</code>(vertical bar)를 통해 타입을 구분하며, ()는 선택 사항입니다. <br />

```typescript

  let union: (string | number);
  union = 'Hello type!';
  union = 123;
  union = false; // Error - TS2322: Type 'false' is not assignable to type 'string | number'.

```

## 인터섹션(Intersection)

<code>&</code>(ampersand)를 사용해 2개 이상의 타입을 조합하는 경우, 이를 인터섹션(Intersection)이라고 합니다. <br />
인터섹션은 새로운 타입을 생성하지 않고 기존의 타입들을 조합할 수 있기 때문에 유용하지만, 자주 사용되는 방법은 아닙니다. <Br />

> 위에서 살펴본 유니언을 마치 ‘또는(Or)’과 같이 이해할 수 있다면, 인터섹션은 ‘그리고(And)’와 같이 이해할 수 있습니다.

```typescript

  // 기존 타입들이 조합 가능하다면 인터섹션을 활용할 수 있습니다.
  interface IUser {
    name: string,
    age: number
  }
  interface IValidation {
    isValid: boolean
  }
  const heropy: IUser = {
    name: 'Heropy',
    age: 36,
    isValid: true // Error -  TS2322: Type '{ name: string; age: number; isValid: boolean; }' is not assignable to type 'IUser'.
  };
  const neo: IUser & IValidation = {
    name: 'Neo',
    age: 85,
    isValid: true
  };

  // 혹은 기존 타입(IUser, IValidation)과 비슷하지만, 정확히 일치하는 타입이 없다면 새로운 타입을 생성해야 합니다.
  interface IUserNew {
    name: string,
    age: number,
    isValid: boolean
  }
  const evan: IUserNew = {
    name: 'Evan',
    age: 36,
    isValid: false
  };

```

## 함수(Function)

화살표 함수를 이용해 타입을 지정할 수 있습니다. <br />
인수의 타입과 반환 값의 타입을 입력합니다. <br />

```typescript

  // myFunc는 2개의 숫자 타입 인수를 가지고, 숫자 타입을 반환하는 함수.
  let myFunc: (arg1: number, arg2: number) => number;
  myFunc = function (x, y) {
    return x + y;
  };

  // 인수가 없고, 반환도 없는 경우.
  let yourFunc: () => void;
  yourFunc = function () {
    console.log('Hello world~');
  };

```

## 타입 추론(Inference)

명시적으로 타입 선언이 되어있지 않은 경우, 타입스크립트는 타입을 추론해 제공합니다. <br />
개념은 매우 단순합니다. <br />

> [추론]: 어떠한 판단을 근거로 삼아 다른 판단을 이끌어 냄.

```typescript

  let num = 12;
  num = 'Hello type!'; // TS2322: Type '"Hello type!"' is not assignable to type 'number'.

```

변수 <code>num</code>을 초기화하면서 숫자 <code>12</code>를 할당해 Number 타입으로 추론되었고, 따라서 <code>'Hello type!'</code>이라는 String 타입의 값은 할당할 수 없기 때문에 에러가 발생합니다.

이렇게 타입스크립트가 타입을 추론하는 경우는 다음과 같습니다.

* 초기화된 변수
* 기본값이 설정된 매개 변수
* 반환 값이 있는 함수

```typescript

  // 초기화된 변수 `num`
  let num = 12;

  // 기본값이 설정된 매개 변수 `b`
  function add(a: number, b: number = 2): number {
    // 반환 값(`a + b`)이 있는 함수
    return a + b;
  }

```

> 타입 추론이 엄격하지 않은 타입 선언을 의미하는 것은 아닙니다. <br />
> 따라서 이를 활용해 모든 곳에 타입을 명시할 필요는 없으며, 많은 경우 더 좋은 코드 가독성을 제공할 수 있습니다. <br />

## 타입 단언(Assertions)

타입스크립트가 타입 추론을 통해 판단할 수 있는 타입의 범주를 넘는 경우, 더 이상 추론하지 않도록 지시할 수 있습니다. <Br />
이를 ‘타입 단언’이라고 하며, 이는 프로그래머가 타입스크립트보다 타입에 대해 더 잘 이해하고 있는 상황을 의미합니다. <br />

> [단언]: 주저하지 아니하고 딱 잘라 말함.

다음 예제를 살펴봅시다. <br />

함수의 매개 변수 <code>val</code>은 유니언 타입으로 문자열(String)이거나 숫자(Number)일 수 있습니다. <br />
그리고 매개 변수 <code>isNumber</code>는 불린(Boolean)이며, 이름을 통해 숫자 여부를 확인하는 값이라는 것을 (우리는) 추론할 수 있습니다. <br />
따라서 우리는 <code>isNumber</code>가 true일 경우 val은 숫자일 것이고, 이에 toFixed를 사용할 수 있음을 확실히 알 수 있습니다. <br />
하지만 타입스크립트는 ‘isNumber’라는 이름만으로 위 내용을 추론할 수 없기 때문에 “<code>val</code>이 문자열인 경우 <code>toFixed</code>를 사용할 수 없다”고 (컴파일 단계에서) 다음과 같은 에러를 반환합니다. <br />

```typescript

  function someFunc(val: string | number, isNumber: boolean) {
    // some logics
    if (isNumber) {
      val.toFixed(2); // Error - TS2339: ... Property 'toFixed' does not exist on type 'string'.
    }
  }

```

따라서 우리는 <code>isNumber</code>가 <code>true</code>일 때 <code>val</code>이 숫자임을 다음과 같이 2가지 방식으로 단언할 수 있습니다. <br />
두 번째 방식(<code>`<number>`val</code>)은 JSX를 사용하는 경우 특정 구문 파싱에서 문제가 발생할 수 있으며, 결과적으로 <Code>.tsx</code> 파일에서는 전혀 사용할 수 없습니다. <br />

```typescript
  
  function someFunc(val: string | number, isNumber: boolean) {
    // some logics
    if (isNumber) {
      // 1. 변수 as 타입
      (val as number).toFixed(2);
      // Or
      // 2. <타입>변수
      // (<number>val).toFixed(2);
    }
  }

```

> 타입 단언은 마치 프로그래머가 타입스크립트에게 “나는 알고 있으니까 나를 믿어!”라고 알려주는 것과 같습니다.

## Non-null 단언 연산자

<code>!</code>를 사용하는 Non-null 단언 연산자(Non-null assertion operator)를 통해 피연산자가 Nullish(<code>null</code>이나 <code>undefined</code>) 값이 아님을 단언할 수 있는데, 변수나 속성에서 간단하게 사용할 수 있기 때문에 유용합니다.

다음 예제 중 <code>fnA</code> 함수를 살펴보면, 매개 변수 <code>x</code>는 함수 내에서 <code>toFixed</code>를 사용하는 숫자 타입으로 처리되지만 <code>null</code>이나 <code>undefined</code>일 수 있기 때문에 에러가 발생합니다.
이를 타입 단언이나 <code>if</code> 조건문으로 해결할 수도 있지만, 마지막 함수와 같이 <code>!</code>를 사용하는 Non-null 단언 연산자를 이용해 간단하게 정리할 수 있습니다.

```typescript
  
  // Error - TS2533: Object is possibly 'null' or 'undefined'.
  function fnA(x: number | null | undefined) {
    return x.toFixed(2);
  }

  // if statement
  function fnD(x: number | null | undefined) {
    if (x) {
      return x.toFixed(2);
    }
  }

  // Type assertion
  function fnB(x: number | null | undefined) {
    return (x as number).toFixed(2);
  }
  function fnC(x: number | null | undefined) {
    return (<number>x).toFixed(2);
  }

  // Non-null assertion operator
  function fnE(x: number | null | undefined) {
    return x!.toFixed(2);
  }

```

특히 컴파일 환경에서 체크하기 어려운 DOM 사용에서 유용합니다. <br />
물론 일반적인 타입 단언을 사용할 수도 있습니다. <Br />

```typescript

  // Error - TS2531: Object is possibly 'null'.
  document.querySelector('.menu-item').innerHTML;

  // Type assertion
  (document.querySelector('.menu-item') as HTMLDivElement).innerHTML;
  (<HTMLDivElement>document.querySelector('.menu-item')).innerHTML;

  // Non-null assertion operator
  document.querySelector('.menu-item')!.innerHTML;

```

## 타입 가드(Guards)

다음 예제와 같이 <code>val</code>의 타입을 매번 보장하기 위해 타입 단언을 여러 번 사용하게 되는 경우가 있습니다.

```typescript
  
  function someFunc(val: string | number, isNumber: boolean) {
    if (isNumber) {
      (val as number).toFixed(2);
      isNaN(val as number);
    } else {
      (val as string).split('');
      (val as string).toUpperCase();
      (val as string).length;
    }
  }

```

이 경우 타입 가드를 제공하면 타입스크립트가 추론 가능한 특정 범위(scope)에서 타입을 보장할 수 있습니다.
타입 가드는 <code>NAME is TYPE</code> 형태의 **타입 술부(Predicate)** 를 반환 타입으로 명시한 함수입니다.
다음 예제에서 타입 술부는 <code>val is number</code>입니다.
타입 단언이 없어지니 훨씬 깔끔합니다.

> [술부]: 주어의 상태, 성질 따위를 서술하는 말.

```typescript

  // 타입 가드
  function isNumber(val: string | number): val is number {
    return typeof val === 'number';
  }

  function someFunc(val: string | number) {
    if (isNumber(val)) {
      val.toFixed(2);
      isNaN(val);
    } else {
      val.split('');
      val.toUpperCase();
      val.length;
    }
  }

```

위 방식뿐만 아니라 제공 가능한 타입 가드가 더 있습니다. <br />
<code>typeof</code>, <code>in</code> 그리고 <code>instanceof</code> 연산자를 직접 사용하는 타입 가드입니다. <br />
비교적 단순한 로직에서 추천되는 방식입니다. <br />

> <code>typeof</code> 연산자는 <code>number</code>, <code>string</code>, <code>boolean</code>, 그리고 <code>symbol</code>만 타입 가드로 인식할 수 있습니다. <br />
> <code>in</code> 연산자의 우변 객체(<code>val</code>)는 <code>any</code> 타입이어야 합니다.

```typescript

  // 기존 예제와 같이 `isNumber`를 제공(추상화)하지 않아도 `typeof` 연산자를 직접 사용하면 타입 가드로 동작합니다.
  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/typeof
  function someFuncTypeof(val: string | number) {
    if (typeof val === 'number') {
      val.toFixed(2);
      isNaN(val);
    } else {
      val.split('');
      val.toUpperCase();
      val.length;
    }
  }

  // 별도의 추상화 없이 `in` 연산자를 사용해 타입 가드를 제공합니다.
  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/in
  function someFuncIn(val: any) {
    if ('toFixed' in val) {
      val.toFixed(2);
      isNaN(val);
    } else if ('split' in val) {
      val.split('');
      val.toUpperCase();
      val.length;
    }
  }

  // 역시 별도의 추상화 없이 `instanceof` 연산자를 사용해 타입 가드를 제공합니다.
  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/instanceof
  class Cat {
    meow() {}
  }
  class Dog {
    woof() {}
  }
  function sounds(ani: Cat | Dog) {
    if (ani instanceof Cat) {
      ani.meow();
    } else {
      ani.woof();
    }
  }

```

## 인터페이스(interface)

인터페이스(Interface)는 타입스크립트 여러 객체를 정의하는 일종의 규칙이며 구조입니다. <br />
다음과 같이 <code>interface</code> 키워드와 함께 사용합니다. <br />

> ‘IUser’에서 ‘I’는 Interface를 의미하는 별칭으로 사용했습니다.

```typescript

  interface IUser {
    name: string,
    age: number,
    isAdult: boolean
  }

  let user1: IUser = {
    name: 'Neo',
    age: 123,
    isAdult: true
  };

  // Error - TS2741: Property 'isAdult' is missing in type '{ name: string; age: number; }' but required in type 'IUser'.
  let user2: IUser = {
    name: 'Evan',
    age: 456
  };

```

<code>:</code>(colon), <code>,</code>(comma) 혹은 기호를 사용하지 않을 수 있습니다.

```typescript
  
  interface IUser {
    name: string,
    age: number
  }
  // Or
  interface IUser {
    name: string;
    age: number;
  }
  // Or
  interface IUser {
    name: string
    age: number
  }

```

다음과 같이 속성에 <code>?</code>를 사용하면 선택적 속성으로 정의할 수 있습니다.<br .>
선택적 속성(Optional properties)에 대해선 Optional 파트에서 따로 설명하지만, <br />
간단하게 표현하면 ‘필수가 아닌 속성으로 정의’하는 방법을 말합니다. 

```typescript

  interface IUser {
    name: string,
    age: number,
    isAdult?: boolean // Optional property
  }

  // `isAdult`를 초기화하지 않아도 에러가 발생하지 않습니다.
  let user: IUser = {
    name: 'Neo',
    age: 123
  };

````

## 읽기 전용 속성(Readonly properties)

<code>readonly</code> 키워드를 사용하면 초기화된 값을 유지해야 하는 **읽기 전용 속성을 정의**할 수 있습니다.

```typescript

  
  interface IUser {
    readonly name: string,
    age: number
  }

  // 초기화
  let user: IUser = {
    name: 'Neo',
    age: 36
  };

  user.age = 85; // Ok
  user.name = 'Evan'; // Error - TS2540: Cannot assign to 'name' because it is a read-only property.

```

만약 모든 속성이 <code>readonly</code>일 경우, [유틸리티(Utility)](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlyt)나 단언(Assertion) 타입을 활용할 수 있습니다.

```typescript

  // All readonly properties
  interface IUser {
    readonly name: string,
    readonly age: number
  }
  let user: IUser = {
    name: 'Neo',
    age: 36
  };
  user.age = 85; // Error
  user.name = 'Evan'; // Error


  // Readonly Utility
  interface IUser {
    name: string,
    age: number
  }
  let user: Readonly<IUser> = {
    name: 'Neo',
    age: 36
  };
  user.age = 85; // Error
  user.name = 'Evan'; // Error


  // Type assertion
  let user = {
    name: 'Neo',
    age: 36
  } as const;
  user.age = 85; // Error
  user.name = 'Evan'; // Error

```

## 함수 타입

함수 타입을 인터페이스로 정의하는 경우, 호출 시그니처(Call signature)라는 것을 사용합니다. <br />
호출 시그니처는 다음과 같이 함수의 매개 변수(parameter)와 반환 타입을 지정합니다. <Br />

```typescript

  interface IName {
    (PARAMETER: PARAM_TYPE): RETURN_TYPE // Call signature
  }

```

간단한 예시를 살펴봅시다. <Br />

인터페이스 <code>IGetUser</code>를 통해 함수 타입을 정의했으며, 이는 <code>name</code> 매개 변수를 하나 가지며(이름이 일치할 필요는 없습니다), <br />
<code>IUser</code> 타입을 반환해야 합니다.

```typescript

  interface IUser {
    name: string
  }
  
  interface IGetUser {
    (name: string): IUser
  }

  // 매개 변수 이름이 인터페이스와 일치할 필요가 없습니다.
  // 또한 타입 추론을 통해 매개 변수를 순서에 맞게 암시적 타입으로 제공할 수 있습니다.
  const getUser: IGetUser = function (n) { // n is name: string
    // Find user logic..
    // ...
    return user;
  };
  getUser('Heropy');

```

## 클래스 타입

인터페이스로 클래스를 정의하는 경우, <code>implements</code> 키워드를 사용합니다.

```typescript
  
  interface IUser {
    name: string,
    getName(): string
  }

  class User implements IUser {
    constructor(public name: string) {}
    getName() {
      return this.name;
    }
  }

  const neo = new User('Neo');
  neo.getName(); // Neo

```

기본적인 사용법은 어렵지 않습니다. <br />
그런데 만약 정의한 클래스를 인수로 사용하는 경우 다음과 같은 문제가 발생할 수 있습니다. <br />
다음 예제에서 인터페이스 <code>ICat</code>은 호출 가능한 구조가 아니기 때문입니다. <br />

```typescript
  
  interface ICat {
    name: string
  }

  class Cat implements ICat {
    constructor(public name: string) {}
  }

  function makeKitten(c: ICat, n: string) {
    return new c(n); // Error - TS2351: This expression is not constructable. Type 'ICat' has no construct signatures.
  }
  const kitten = makeKitten(Cat, 'Lucy');
  console.log(kitten);

```

이를 위해 구성 시그니처(Construct signature)를 제공할 수 있습니다.
구성 시그니처는 위에서 살펴본 호출 시그니처와 비슷하지만, <code>new</code> 키워드를 사용해야 합니다.

```typescript
  
  interface IName {
    new (PARAMETER: PARAM_TYPE): RETURN_TYPE // Construct signature
  }

```

위에서 봤던 예제를 다음과 같이 수정합니다.<br />
<code>ICatConstructor</code>라는 구성 시그니처를 가지는 호출 가능한 인터페이스를 정의하면, 문제없이 동작하는 것을 확인할 수 있습니다. <br />

```typescript

  interface ICat {
    name: string
  }
  interface ICatConstructor {
    new (name: string): ICat;
  }

  class Cat implements ICat {
    constructor(public name: string) {}
  }

  function makeKitten(c: ICatConstructor, n: string) {
    return new c(n); // ok
  }
  const kitten = makeKitten(Cat, 'Lucy');
  console.log(kitten);

```

비슷하지만 좀 더 재미있는 예제를 준비했습니다. <br />
에러가 발생하는 부분을 확인하고 내용을 이해했다면 충분합니다. <br />

```typescript
  
  interface IFullName {
    firstName: string,
    lastName: string
  }
  interface IFullNameConstructor {
    new(firstName: string): IFullName; // Construct signature
  }


  function makeSon(c: IFullNameConstructor, firstName: string) {
    return new c(firstName);
  }
  function getFullName(son: IFullName) {
    return `${son.firstName} ${son.lastName}`;
  }


  // Anderson family
  class Anderson implements IFullName {
    public lastName: string;
    constructor (public firstName: string) {
      this.lastName = 'Anderson';
    }
  }
  const tomas = makeSon(Anderson, 'Tomas');
  const jack = makeSon(Anderson, 'Jack');
  getFullName(tomas); // Tomas Anderson
  getFullName(jack); // Jack Anderson


  // Smith family?
  class Smith implements IFullName {
    public lastName: string;
    constructor (public firstName: string, agentCode: number) {
      this.lastName = `Smith ${agentCode}`;
    }
  }
  const smith = makeSon(Smith, 7); // Error - TS2345: Argument of type 'typeof Smith' is not assignable to parameter of type 'IFullNameConstructor'.
  getFullName(smith);

```
```text

저 코드에서 에러가 나는 이유는 makeSon의 첫번째 파라미터는 IFullNameConstructor 타입이라야 하는데, Smith는 타입을 만족하지 못하기 때문입니다. IFullNameConstructor 정의를 보시면 firstName을 받아서 IFullName 오브젝트를 리턴하는 컨스트럭터가 있어야 하는데, Smith 컨스트럭터는 (string, number)을 받아서 IFullName을 리턴합니다.
Anderson 클래스 넣어보시면 작동하는거 확인 가능힙니다.
[보기](https://typescript-play.js.org/?fbclid=IwAR3Vmd0DE9y0gMhAIhJRGr2NthNiA5Z_PMqOAGzJAP3iY_oKwOozKsxWNkE#code/JYOwLgpgTgZghgYwgAgJIDECuAbbA5OAWxQG8AoM5K5GYKAZzAOIC5lGpQBzAGguuTY4jZhDYduFAL4VQkWIhQYc+IhADCAexAdMCMJqjJylaiAgB3ABS0GTNeLCcQXAJRtluUQG5kAej9kLR0nPTB2YC4QODBMKAhpChhMEH1gbWRCOABrCABlbSsEDywvNWDdfUMeGjoRB3Ynbldjfmp42KgQZHMLZAQbOvtiV29EsmTUsHTurggwUtViK3ptEpVRFpMBDrjugAMAEhJVkAA6W3riKWRj07OhK4gpfbGyGTIA5ABBEAATaCnGhEYDYACeFAQj3oP3+gIywEIAAdsBBiOAYZ4lqQ2lQkZgAEbYYAIQTCYZiRrOLhvAQIbSVAxQKz4okk2p2USOalbXECZBgAAWwHoD3JomQAF5kAByX4AhjaGW06gfD70kICzRZGHSrK5AogKzy+EgGoygAq2uEMtGkIZ4QAVohslLMjl8oUTYqzbKAFIu21vOYLDZqKwGHWjfyBK062EK04UEOLURWZ0IbLRr4BzMJ00UL55QjAIXAkvggD8kOhyGLpcFyERKLREAxaFTalapjxhOJpMeFO53BVVA1jMMLL77MuQ6pzVa-OoqPCcDm4C0ALdAGZR-yhSKxU83ft62Xjmu22BN89Xny1fbNY7NCg9R7Dca4T6agAiP0vn87TIcdNFRB5NC4KwUzDZZnwgVxRiAA)
```

























































