# 변경사항

## 2020년 2월
 * 다음 파트들을 추가했습니다.
   * keyof <인터페이스(Interface)/인덱싱 가능 타입(Indexable Types)>
   * 타입 별칭(Type Aliases)
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 3월
 * 다음의 파트들을 추가했습니다.
   * 알 수 없는 타입(Unknown) <타입 기본(Types)/타입 선언>
   * 인터섹션(Intersection) <타입 기본(Types)/타입 선언>
   * 함수 타입 <인터페이스(Interface)>
   * 클래스 타입 <인터페이스(Interface)>
   * 인터페이스 확장 <인터페이스(Interface)>
   * 함수
   * this <함수>
   * 명시적 this <함수>
   * 오버로드(Overloads) <함수> 
 * 목차 흐름을 위해 ‘인덱스 시그니처(Index signature)’ 파트 제목을 삭제했습니다.(내용은 삭제하지 않았습니다)
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 4월
 * 다음의 파트들을 추가했습니다.
   * TS Node <개발환경>
   * 모듈
   * 내보내기(export)와 가져오기(import) <모듈>
   * 모듈의 타입 선언(Ambient module declaration) <모듈>
   * Definitely Typed(@types) <모듈>
   * typeRoots와 types 옵션 <모듈>
 * 컴파일 옵션에 대한 여러 링크를 추가했습니다.
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 6월
  * 다음의 파트들을 추가했습니다.
    * 제약 조건(Constraints) <제네릭(Generic)>
     * 조건부 타입(Conditional Types) <제네릭(Generic)>
     * infer <제네릭(Generic)>
     * Partial <TS 유틸리티 타입>
     * Required <TS 유틸리티 타입>
     * Readonly <TS 유틸리티 타입>
     * Record <TS 유틸리티 타입>
     * Pick <TS 유틸리티 타입>
     * Omit <TS 유틸리티 타입>
     * Exclude <TS 유틸리티 타입>
     * Extract <TS 유틸리티 타입>
     * NonNullable <TS 유틸리티 타입>
     * Parameters <TS 유틸리티 타입>
     * ConstructorParameters <TS 유틸리티 타입>
     * ReturnType <TS 유틸리티 타입>
     * InstanceType <TS 유틸리티 타입>
     * ThisParameterType <TS 유틸리티 타입>
     * OmitThisParameter <TS 유틸리티 타입>
     * ThisType <TS 유틸리티 타입>
   * ‘타입 가드’ 파트에 in 연산자에 대한 내용을 추가했습니다.
   * 일부 내용과 오타 등을 수정했습니다.
   
## 타입스크립트 개요

[타입스크립트(TypeScript)](https://www.typescriptlang.org/index.html)는 Microsoft에서 개발하고 유지/관리하는 [Apache 라이센스](https://ko.wikipedia.org/wiki/%EC%95%84%ED%8C%8C%EC%B9%98_%EB%9D%BC%EC%9D%B4%EC%84%A0%EC%8A%A4)가 부여된 오픈 소스입니다. <br />
일반 자바스크립트로 컴파일되는 자바스크립트 Superset(상위 호환)으로 2012년 10월에 처음 릴리스 되었습니다. <br />

## 왜 타입스크립트인가?

C#과 Java 같은 체계적이고 정제된 언어들에서 사용하는 강한 타입 시스템은 높은 가독성과 코드 품질 등을 제공할 수 있고 런타임이 아닌 컴파일 환경에서 에러가 발생해 치명적인 오류들을 더욱더 쉽게 잡아낼 수 있습니다. <br />

반면 자바스크립트는 타입 시스템이 없는 동적 프로그래밍 언어로, 자바스크립트 변수는 문자열, 숫자, 불린 등 여러 타입의 값을 가질 수 있습니다. <br />
이를 약한 타입 언어라고 표현할 수 있으며 비교적 유연하게 개발할 수 있는 환경을 제공하는 한편 런타임 환경에서 쉽게 에러가 발생할 수 있는 단점을 가집니다. <br />

그리고 타입스크립트는 이러한 자바스크립트에 강한 타입 시스템을 적용해 대부분의 에러를 컴파일 환경에서 코드를 입력하는 동안 체크할 수 있습니다. <br />

## 타입스크립트 사용법

자바스크립트가 <code>.js</code> 확장자를 가진 파일로 작성되는 것과 같이 타입스크립트는 .ts 확장자를 가진 파일로 작성할 수 있고, 작성 후 타입스크립트 컴파일러를 통해 자바스크립트 파일로 컴파일하여 사용하게 됩니다.

```typescript

  $ tsc sample.ts
  # compiled to `sample.js`

```

## 타입스크립트의 기능

* **크로스 플랫폼 지원**: 자바스크립트가 실행되는 모든 플랫폼에서 사용할 수 있습니다.
* **객체 지향 언어**: 클래스, 인터페이스, 모듈 등의 강력한 기능을 제공하며, 순수한 객체 지향 코드를 작성할 수 있습니다.
* **정적 타입**: 정적 타입을 사용하기 때문에 코드를 입력하는 동안에 오류를 체크할 수 있습니다.(단 에디터 혹은 플러그인의 도움의 필요)
* **DOM 제어**: 자바스크립트와 같이 DOM을 제어해 요소를 추가하거나 삭제할 수 있습니다.
* **최신 ECMAScript 기능 지원**: ES6 이상의 최신 자바스크립트 문법을 손쉽게 지원할 수 있습니다.

# 개발환경

## VSCode와 WebStorm

[VSCode(Visual Studio Code)](https://code.visualstudio.com/)와 (WebStorm)[https://www.jetbrains.com/ko-kr/webstorm/]은 타입스크립트 지원 기능이 내장되어 있기 때문에 별도의 설정 없이도 타입스크립트 파일을(<code>.ts, tsconfig.json</code> 등) 인식할 수 있고 코드 검사, 빠른 수정, 실행 및 디버깅 등의 다양한 기능을 바로 사용할 수 있습니다.
단, 컴파일러는 포함되어 있지 않기 때문에 별도로 설치해야 합니다.(E.g. <code>npm install typescript</code>)

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-vscode-error.jpg" width = 90%></img></p>
<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-webstorm-error.jpg" width = 90%></img></p>

## 컴파일러 설치

<code>tsc</code> 명령을 사용하기 위해 다음과 같이 타입스크립트를 전역 설치할 수 있습니다. <br />
타입스크립트 파일을 경로로 지정하면 해당 파일을 컴파일합니다. <br />

```typescript

  $ npm install -g typescript
  $ tsc --version
  $ tsc ./src/index.ts

```

혹은, 단일 프로젝트에서만 사용하길 희망하는 경우 일반 지역 설치 후 <code>npx tsc</code> 명령으로 실행할 수도 있습니다.

```typescript

  $ npm install -D typescript
  $ npx tsc --version 
  $ npx tsc ./src/index.ts

```

## 컴파일러 옵션

타입스크립트 (컴파일을 위한 다양한 옵션)[https://www.typescriptlang.org/docs/handbook/compiler-options.html을 지정할 수 있습니다.

* 공식 문서: https://www.typescriptlang.org/docs/handbook/compiler-options.html
* 공식 문서 한글 번역: https://typescript-kr.github.io/pages/Compiler%20Options.html
* vomvoru’s blog: https://vomvoru.github.io/blog/tsconfig-compiler-options-kr/

```typescpript

  $ tsc ./src/index.ts --watch --strict true --target ES6 --lib ES2015,DOM --module CommonJS
  
```

> VScode와 WebStorm을 사용하는 경우, tsconfig.json 파일을 프로젝트 루트 경로에 생성하면 에디터에 의해 구성 옵션이 분석됩니다.

```typescript

  {
    "compilerOptions": {
      "strict": true,
      "target": "ES6",
      "lib": ["ES2015", "DOM"],
      "module": "CommonJS"
    },
    "include": [
      "src/**/*.ts"
    ],
    "exclude": [
      "node_modules"
    ]
  }

```

```typescript

  $ tsc --watch
  
```

## TypeScript Playground

https://www.typescriptlang.org/play/index.html

타입스크립트 공식 페이지에서 제공하는 REPL로, 작성한 내용이 컴파일러 옵션에 따라 어떻게 자바스크립트로 변환되는지 바로 확인할 수 있습니다.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-playground.jpg" width = 90%></img></p>

## Repl.it

https://repl.it/languages/typescript

파일과 디렉터리로 관리되는 타입스크립트 프로젝트를 손쉽게 구성할 수 있습니다. <br />
간단한 프로젝트로 타입스크립트를 테스트하기 좋습니다. <br />

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-repl.jpg" width = 90%></img></p>

## Parcel

타입스크립트를 로컬 환경에서 빠르게 테스트하고 싶다면 [Parcel 번들러](https://ko.parceljs.org/getting_started.html)가 좋은 선택입니다. <br />
다음과 같이 간단하게 프로젝트를 구성합니다. <br />

```typescript
  
  $ mkdir typescript-test
  $ cd typescript-test
  $ npm init -y
  $ npm install -D typescript parcel-bundler

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-test-with-parcel-bundler.jpg" width = 90%></img></p>

<code>tsconfig.json</code> 파일을 생성하고 원하는 옵션을 추가합니다. <br />
다음은 예시입니다. <br />

```typescript

  {
    "compilerOptions": {
      "strict": true
    },
    "exclude": [
      "node_modules"
    ]
  }

```

<code>main.ts</code> 파일을 생성하고 원하는 타입스크립트 코드를 입력합니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  
  const sum: number = add(1, 2);
  console.log(sum);

```

<code>index.html</code> 파일을 생성하고 다음과 같이 <code>.js</code>가 아닌 <code>.ts</code> 파일을 연결합니다. <br />
Parcel 번들러가 빌드시 자동으로 타입스크립트를 컴파일합니다. <br />

```HTML

  <!doctype html>
  <html>
  <head>
    <meta charset="UTF-8">
    <title>TypeScript Test</title>
  </head>
  <body>
    <script src="main.ts"></script>
  </body>
  </html>

```

마지막으로 다음과 같이 진입 파일로 <code>index.html</code>를 지정하고 Parcel 번들러로 빌드합니다.

```typescript

  $ npx parcel index.html
  # Server running at http://localhost:1234

```

## TS Node

NodeJS 환경에서 테스트하고 싶다면 [TS Node](https://github.com/TypeStrong/ts-node)를 사용하세요. <br />
다음과 같이 간단하게 프로젝트를 구성합니다. <Br />

```text

  $ mkdir typescript-test
  $ cd typescript-test
  $ npm init -y
  $ npm install -D typescript @types/node ts-node

```

> [@types/node](https://github.com/DefinitelyTyped/DefinitelyTyped)는 Node.js API를 위한 타입 선언 모듈입니다.
> **@types**에 대한 자세한 내용은 ‘모듈’ 파트를 참고하세요.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-test-with-ts-node.jpg" width = 90%></img></p>

<code>tsconfig.json</code> 파일을 생성하고 원하는 옵션을 추가합니다. <br />
다음은 예시입니다. <br />

```json

  {
    "compilerOptions": {
      "strict": true,
      "module": "CommonJS"
    },
    "exclude": [
      "node_modules"
    ]
  }

```

<code>main.ts</code> 파일을 생성하고 원하는 타입스크립트 코드를 입력합니다.

```typescript

  console.log('TypeScript on NodeJS!');
  
```

TS Node를 사용해 <code>main.ts</code>를 실행합니다.

```typescript
  
  $ npx ts-node main.js
  # TypeScript on NodeJS!

```

# 타입 기본(Types)

## 타입 지정

타입스크립트는 일반 변수, 매개 변수(Parameter), 객체 속성(Property) 등에 : TYPE과 같은 형태로 타입을 지정할 수 있습니다.

```typescript

  function someFunc(a: TYPE_A, b: TYPE_B): TYPE_RETURN {
    return a + b;
  }
  let some: TYPE_SOME = someFunc(1, 2);
  
```

다음 예시를 보면,
<code>add</code> 함수의 매개 변수 <code>a</code>와 <code>b</code>는 <code>number</code> 타입이어야 한다고 지정했고,
그렇게 실행된 함수의 반환 값은 숫자로 추론(Inference)되기 때문에 변수 <code>sum</code>도 <code>number</code> 타입이어야 한다고 지정했습니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  const sum: number = add(1, 2);
  console.log(sum); // 3

```

자바스크립트로 컴파일한 결과는 다음과 같습니다.

```typescript

  "use strict";
  function add(a, b) {
    return a + b;
  }
  const sum = add(1, 2);
  console.log(sum);

```

## 타입 에러

만약 다음과 같이 변수 <code>sum</code>을 <code>number</code>가 아닌 <code>string</code> 타입이어야 한다고 지정했다면, 컴파일조차 하지 않고 코드를 작성하는 시점에서 에러가 발생합니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  const sum: string = add(1, 2);
  console.log(sum);

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-error-ts2322.jpg" width = 90%></img></p>

위 이미지에서 [TS2322](https://www.google.com/search?newwindow=1&sxsrf=ACYBGNQeWU6z1K7DXQ9oM0VR4gV-KPSd2Q%3A1580379601357&ei=0a0yXpuyFZyCr7wPi96owAU&q=TS2322&oq=TS2322&gs_l=psy-ab.3..35i39j0j0i203l4j0j0i203l3.15216190.15216190..15216895...0.0..0.114.321.1j2......0....2j1..gws-wiz.......0i67j0i7i30j0i7i10i30j0i5i30j0i5i10i30.1W9DJiS_O3c&ved=0ahUKEwjb3v7ljKvnAhUcwYsBHQsvClgQ4dUDCAs&uact=5)라는 에러 코드를 볼 수 있으며, 이를 검색하면 쉽게 에러 코드에 대한 정보를 얻을 수 있습니다.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/search-typescript-error-code.jpg" width = 90%></img></p>

## 타입 선언

## 불린: Boolean

단순한 참(<code>true</code>)/거짓(<code>false</code>) 값을 나타냅니다.

```typescript

  let isBoolean: boolean;
  let isDone: boolean = false;

```

## 숫자: Number

모든 부동 소수점 값을 사용할 수 있습니다. <br />
ES6에 도입된 2진수 및 8진수 리터럴도 지원합니다. <br />

```typescript

  let num: number;
  let integer: number = 6;
  let float: number = 3.14;
  let hex: number = 0xf00d; // 61453
  let binary: number = 0b1010; // 10
  let octal: number = 0o744; // 484
  let infinity: number = Infinity;
  let nan: number = NaN;

```

## 문자열: String

문자열을 나타냅니다.
작은따옴표(<code>'</code>), 큰따옴표(<code>"</code>) 뿐만 아니라 ES6의 템플릿 문자열도 지원합니다.

```typescript
  
  let str: string;
  let red: string = 'Red';
  let green: string = "Green";
  let myColor: string = `My color is ${red}.`;
  let yourColor: string = 'Your color is' + green;

```

## 배열: Array

순차적으로 값을 가지는 일반 배열을 나타냅니다. <br />
배열은 다음과 같이 두 가지 방법으로 타입을 선언할 수 있습니다. <Br />


```typescript

  // 문자열만 가지는 배열
  let fruits: string[] = ['Apple', 'Banana', 'Mango'];
  // Or
  let fruits: Array<string> = ['Apple', 'Banana', 'Mango'];

  // 숫자만 가지는 배열
  let oneToSeven: number[] = [1, 2, 3, 4, 5, 6, 7];
  // Or
  let oneToSeven: Array<number> = [1, 2, 3, 4, 5, 6, 7];

```

유니언 타입(다중 타입)의 ‘문자열과 숫자를 동시에 가지는 배열’도 선언할 수 있습니다.

```typescript
  
  let array: (string | number)[] = ['Apple', 1, 2, 'Banana', 'Mango', 3];
  // Or
  let array: Array<string | number> = ['Apple', 1, 2, 'Banana', 'Mango', 3];

```

배열이 가지는 항목의 값을 단언할 수 없다면 <code>any</code>를 사용할 수 있습니다.

```typescript
  
  let someArr: any[] = [0, 1, {}, [], 'str', false];
  
```

인터페이스(Interface)나 커스텀 타입(Type)을 사용할 수도 있습니다.

```typescript

  interface IUser {
    name: string,
    age: number,
    isValid: boolean
  }
  let userArr: IUser[] = [
    {
      name: 'Neo',
      age: 85,
      isValid: true
    },
    {
      name: 'Lewis',
      age: 52,
      isValid: false
    },
    {
      name: 'Evan',
      age: 36,
      isValid: true
    }
  ];

```

유용하진 않지만, 다음과 같이 특정한 값으로 타입을 대신해 작성할 수도 있습니다.

```typescript

  let array = 10[];
  array = [10];
  array.push(10);
  array.push(11); // Error - TS2345

```

읽기 전용 배열을 생성할 수도 있습니다. <br />
<code>readonly</code> 키워드나 <code>ReadonlyArray</code> 타입을 사용하면 됩니다.

```typescript

  let arrA: readonly number[] = [1, 2, 3, 4];
  let arrB: ReadonlyArray<number> = [0, 9, 8, 7];

  arrA[0] = 123; // Error - TS2542: Index signature in type 'readonly number[]' only permits reading.
  arrA.push(123); // Error - TS2339: Property 'push' does not exist on type 'readonly number[]'.

  arrB[0] = 123; // Error - TS2542: Index signature in type 'readonly number[]' only permits reading.
  arrB.push(123); // Error - TS2339: Property 'push' does not exist on type 'readonly number[]'.

```

## 튜플: Tuple

Tuple 타입은 배열과 매우 유사합니다.
차이점이라면 **정해진 타입의 고정된 길이(length) 배열**을 표현합니다.

```typescript

  let tuple: [string, number];
  tuple = ['a', 1];
  tuple = ['a', 1, 2]; // Error - TS2322
  tuple = [1, 'a']; // Error - TS2322

```

다음과 같이 데이터를 개별 변수로 지정하지 않고, 단일 Tuple 타입으로 지정해 사용할 수 있습니다.

```typescript

  // Variables
  let userId: number = 1234;
  let userName: string = 'HEROPY';
  let isValid: boolean = true;

  // Tuple
  let user: [number, string, boolean] = [1234, 'HEROPY', true];
  console.log(user[0]); // 1234
  console.log(user[1]); // 'HEROPY'
  console.log(user[2]); // true

```

나아가 위 방식을 활용해 다음과 같은 Tuple 타입의 배열(2차원 배열)을 사용할 수 있습니다.

```typescript
  
  let users: [number, string, boolean][];
  // Or
  // let users: Array<[number, string, boolean]>;

  users = [[1, 'Neo', true], [2, 'Evan', false], [3, 'Lewis', true]];

```

역시 값으로 타입을 대신할 수도 있습니다.

```typescript

  let tuple: [1, number];
  tuple = [1, 2];
  tuple = [1, 3];
  tuple = [2, 3]; // Error - TS2322: Type '2' is not assignable to type '1'.

```


















































