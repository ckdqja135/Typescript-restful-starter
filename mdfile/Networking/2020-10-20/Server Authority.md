### 시작 
Server Authority는 말그대로 서버가 권한을 가지고 있는 형태이다. <br />
서버가 모든것을 판단해서 중재자이고, 심판이면서, 플레이어이면서 모든걸 다 한다고 보면 된다. <br />
이 방식은 상당히 고전적이면서 단순하다. 흔히 [CS방식(Client & Server)](https://joesimong.blogspot.com/2014/05/cs-web.html)이라고 하는데 <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/96531328-5ee6b500-12c4-11eb-8240-c2de251ea08b.png" width = 70%> </img></p>
클라이언트가 있고, 서버가 있을 때 클라이언트가 서버에게 질의를 하고, 서버가 클라이언트에게 응답을 하는 방식이 된다. <br />
이 방식을 가장 흔하게 볼 수 있는 방식이 웹 서버이다. <Br />

게임 서버도 이와 비슷하다 보면 된다. <br />
그런데 문제가 있는데 이 방식에서는 항상 클라이언트가 묻고, 서버가 응답하는 구조인데 클라이언트가 묻지 않으면 서버는 응답을 하지 않는다. <br />

예전에 웹서버는 다이나믹한 변경을 주고 싶어서 1초마다 갱신되는 정보가 있다 가정했을 때 1초마다 계속 달라진 것이 있는지 클라이언트가 서버에게 질문하는 [폴링(polling)](https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))방식을 썼었다. <br />

HTML2가 되고, [Long Polling방식](https://wondongho.tistory.com/69)이 들어가면서 전에는 질의하고 응답하면 커넥션을 끊었는데 바로 끊지 않고 유지하는 방식으로해서 서버가 필요할 때 응답할 수 있게 하는 방식을 썼었고, <Br />
웹소켓으로 해서 커넥션을 유지하는 방식을 쓰기도 했다. <br />

게임서버는 기본적으로 커넥션을 유지하는 방식이다. 클라이언트가 질의하고, 서버가 응답하기도 하지만 서버가 바로 알림을 날리기도 한다. <br />
그래서 커넥션을 한 번 맺어놓고 계속 유지하고 있으면서 계속 질의하고, 응답하고를 반복하다 때때로 서버가 알림을 알려주는 구조로 되어있다. <br />
이 방식이 Server Authority 방식이다. 서버에게 질문하고, 응답받고, 알림받고 이게 다 이다. <br />

가령 예를 들어 MMORPG를 만든다고 가정했을 때 MMORPG에서 가장 기본적인 행동이라고 보면 이동, 액션이다. <br />
이동한다고 치면 클라이언트에서 고전적인 MMORPG방식인 클릭 & 무브 방식으로 보자 (땅찍기라고도 한다.) <BR />
특정 위치에 땅을 찍었을 때 클라이언트가 서버에게 패킷을 보낸다. 이 때 날리는 패킷이 Requet_Move라고 가정하자. <br />
그러면 찍은 위치, 좌표를 패킷에 담아서 보내는데, 서버에서는 똑같은 게임환경을 가지고 있는데 서버안에 있는 해당 캐릭터가 그 위치로 이동하기 시작한다. <br />
그리고 클라이언트에게 움직이고 있다고 패킷을 준다. 이 때 날리는 패킷을 Response_Move라고 하자. <br />
그리고 알림으로 조금씩 이동할 때마다 변경이 되는 위치를 알려준다. 그러면 클라이언트에서 위치가 조금씩 변하는 경로들을 따라가면서 위치를 변경시키는 방식이 된다. <br />
그래서 클라이언트에서의 관건은 이 위치를 얼마나 자연스럽게 표시되냐가 관건이고, 서버에서는 이 변경되고 있는 위치를 얼마나 잘 체이서화하냐, 이 주변에 얼마나 효율적으로 살포를 해주냐이다. <br />

액션도 마찬가지이다. <br />
클라이언트가 몬스터에게 스킬을 사용했을 때 서버에게 스킬을 썼다는 패킷을 날리게 된다. 이 때 날아가는 패킷을 Requst_skill이라고 가정하자. <br />
그러면 서버에서 해당 클라이언트가 스킬을 사용하는 로직을 실행하고, 응답을 알려준다. 이 때 응답으로 오는 패킷을 Response_skill이라고 가정하자. <br />
그러면 이 패킷을 통해서 스킬이 정상적으로 사용됐다, 사용이 불가능하다, 등등의 응답을 주고, 서버에서 스킬이 사용되면 여러가지 효과가 나타날텐데 <br />
그 효과들은 알림으로 알려준다. <br />

Server Authority방식에서 구현자체는 어려운건 아닌데 문제는 서버가 로직을 들고 있어야 한다는 점이다. <br />
모든 플레이어들을 컨트롤 해야 하는데 모든 플레이어 요청을 응답 해주어야 하고, 모든 게임환경을 다 컨트롤 해야한다. <br />
그래서 게임 월드를 얼마나 잘 컨트롤 하냐가 관건이 된다. <br />

그래서 Server Authority방식은 게임 네트워킹 쪽보다는 게임 월드를 얼마나 효율적으로 컨트롤 할 수 있느냐의 기술에 관건이 달려 있다. <br />
이 하나의 서버가 얼마나 많은 유저를 컨트롤 할 수 있고, 얼마나 큰 월드를 유지할 수 있느냐가 중요하게 된다. <br />

그래서 흔히 말하는게 10k Server라고 꿈의 서버라고도 하는데 유저(클라이언트) 수가 만명이 하나의 서버에 접속해서 유지하는 구조이다. <br /> 
웹 서버 같은 경우에는 만개의 Request가 동시에 날라와도 분산하여 처리하기 때문에 크게 문제가 안되는데 게임서버에서는 실시간으로 발생하기 때문에 <br />
초당 10개의 패킷이 날아갈 수 있어야 실시간으로 볼 수 있어서 초당 10만개의 패킷이 날아가야 한다. <br />
이러한 실시간 서버를 어떻게 만드느냐가 관건이 된다. <br />
