# 변경사항

## 2020년 2월
 * 다음 파트들을 추가했습니다.
   * keyof <인터페이스(Interface)/인덱싱 가능 타입(Indexable Types)>
   * 타입 별칭(Type Aliases)
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 3월
 * 다음의 파트들을 추가했습니다.
   * 알 수 없는 타입(Unknown) <타입 기본(Types)/타입 선언>
   * 인터섹션(Intersection) <타입 기본(Types)/타입 선언>
   * 함수 타입 <인터페이스(Interface)>
   * 클래스 타입 <인터페이스(Interface)>
   * 인터페이스 확장 <인터페이스(Interface)>
   * 함수
   * this <함수>
   * 명시적 this <함수>
   * 오버로드(Overloads) <함수> 
 * 목차 흐름을 위해 ‘인덱스 시그니처(Index signature)’ 파트 제목을 삭제했습니다.(내용은 삭제하지 않았습니다)
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 4월
 * 다음의 파트들을 추가했습니다.
   * TS Node <개발환경>
   * 모듈
   * 내보내기(export)와 가져오기(import) <모듈>
   * 모듈의 타입 선언(Ambient module declaration) <모듈>
   * Definitely Typed(@types) <모듈>
   * typeRoots와 types 옵션 <모듈>
 * 컴파일 옵션에 대한 여러 링크를 추가했습니다.
 * 일부 내용과 오타 등을 수정했습니다.

## 2020년 6월
  * 다음의 파트들을 추가했습니다.
    * 제약 조건(Constraints) <제네릭(Generic)>
     * 조건부 타입(Conditional Types) <제네릭(Generic)>
     * infer <제네릭(Generic)>
     * Partial <TS 유틸리티 타입>
     * Required <TS 유틸리티 타입>
     * Readonly <TS 유틸리티 타입>
     * Record <TS 유틸리티 타입>
     * Pick <TS 유틸리티 타입>
     * Omit <TS 유틸리티 타입>
     * Exclude <TS 유틸리티 타입>
     * Extract <TS 유틸리티 타입>
     * NonNullable <TS 유틸리티 타입>
     * Parameters <TS 유틸리티 타입>
     * ConstructorParameters <TS 유틸리티 타입>
     * ReturnType <TS 유틸리티 타입>
     * InstanceType <TS 유틸리티 타입>
     * ThisParameterType <TS 유틸리티 타입>
     * OmitThisParameter <TS 유틸리티 타입>
     * ThisType <TS 유틸리티 타입>
   * ‘타입 가드’ 파트에 in 연산자에 대한 내용을 추가했습니다.
   * 일부 내용과 오타 등을 수정했습니다.
   
## 타입스크립트 개요

[타입스크립트(TypeScript)](https://www.typescriptlang.org/index.html)는 Microsoft에서 개발하고 유지/관리하는 [Apache 라이센스](https://ko.wikipedia.org/wiki/%EC%95%84%ED%8C%8C%EC%B9%98_%EB%9D%BC%EC%9D%B4%EC%84%A0%EC%8A%A4)가 부여된 오픈 소스입니다. <br />
일반 자바스크립트로 컴파일되는 자바스크립트 Superset(상위 호환)으로 2012년 10월에 처음 릴리스 되었습니다. <br />

## 왜 타입스크립트인가?

C#과 Java 같은 체계적이고 정제된 언어들에서 사용하는 강한 타입 시스템은 높은 가독성과 코드 품질 등을 제공할 수 있고 런타임이 아닌 컴파일 환경에서 에러가 발생해 치명적인 오류들을 더욱더 쉽게 잡아낼 수 있습니다. <br />

반면 자바스크립트는 타입 시스템이 없는 동적 프로그래밍 언어로, 자바스크립트 변수는 문자열, 숫자, 불린 등 여러 타입의 값을 가질 수 있습니다. <br />
이를 약한 타입 언어라고 표현할 수 있으며 비교적 유연하게 개발할 수 있는 환경을 제공하는 한편 런타임 환경에서 쉽게 에러가 발생할 수 있는 단점을 가집니다. <br />

그리고 타입스크립트는 이러한 자바스크립트에 강한 타입 시스템을 적용해 대부분의 에러를 컴파일 환경에서 코드를 입력하는 동안 체크할 수 있습니다. <br />

## 타입스크립트 사용법

자바스크립트가 <code>.js</code> 확장자를 가진 파일로 작성되는 것과 같이 타입스크립트는 .ts 확장자를 가진 파일로 작성할 수 있고, 작성 후 타입스크립트 컴파일러를 통해 자바스크립트 파일로 컴파일하여 사용하게 됩니다.

```typescript

  $ tsc sample.ts
  # compiled to `sample.js`

```

## 타입스크립트의 기능

* **크로스 플랫폼 지원**: 자바스크립트가 실행되는 모든 플랫폼에서 사용할 수 있습니다.
* **객체 지향 언어**: 클래스, 인터페이스, 모듈 등의 강력한 기능을 제공하며, 순수한 객체 지향 코드를 작성할 수 있습니다.
* **정적 타입**: 정적 타입을 사용하기 때문에 코드를 입력하는 동안에 오류를 체크할 수 있습니다.(단 에디터 혹은 플러그인의 도움의 필요)
* **DOM 제어**: 자바스크립트와 같이 DOM을 제어해 요소를 추가하거나 삭제할 수 있습니다.
* **최신 ECMAScript 기능 지원**: ES6 이상의 최신 자바스크립트 문법을 손쉽게 지원할 수 있습니다.

# 개발환경

## VSCode와 WebStorm

[VSCode(Visual Studio Code)](https://code.visualstudio.com/)와 (WebStorm)[https://www.jetbrains.com/ko-kr/webstorm/]은 타입스크립트 지원 기능이 내장되어 있기 때문에 별도의 설정 없이도 타입스크립트 파일을(<code>.ts, tsconfig.json</code> 등) 인식할 수 있고 코드 검사, 빠른 수정, 실행 및 디버깅 등의 다양한 기능을 바로 사용할 수 있습니다.
단, 컴파일러는 포함되어 있지 않기 때문에 별도로 설치해야 합니다.(E.g. <code>npm install typescript</code>)

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-vscode-error.jpg" width = 90%></img></p>
<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-webstorm-error.jpg" width = 90%></img></p>

## 컴파일러 설치

<code>tsc</code> 명령을 사용하기 위해 다음과 같이 타입스크립트를 전역 설치할 수 있습니다. <br />
타입스크립트 파일을 경로로 지정하면 해당 파일을 컴파일합니다. <br />

```typescript

  $ npm install -g typescript
  $ tsc --version
  $ tsc ./src/index.ts

```

혹은, 단일 프로젝트에서만 사용하길 희망하는 경우 일반 지역 설치 후 <code>npx tsc</code> 명령으로 실행할 수도 있습니다.

```typescript

  $ npm install -D typescript
  $ npx tsc --version 
  $ npx tsc ./src/index.ts

```

## 컴파일러 옵션

타입스크립트 (컴파일을 위한 다양한 옵션)[https://www.typescriptlang.org/docs/handbook/compiler-options.html을 지정할 수 있습니다.

* 공식 문서: https://www.typescriptlang.org/docs/handbook/compiler-options.html
* 공식 문서 한글 번역: https://typescript-kr.github.io/pages/Compiler%20Options.html
* vomvoru’s blog: https://vomvoru.github.io/blog/tsconfig-compiler-options-kr/

```typescpript

  $ tsc ./src/index.ts --watch --strict true --target ES6 --lib ES2015,DOM --module CommonJS
  
```

> VScode와 WebStorm을 사용하는 경우, tsconfig.json 파일을 프로젝트 루트 경로에 생성하면 에디터에 의해 구성 옵션이 분석됩니다.

```typescript

  {
    "compilerOptions": {
      "strict": true,
      "target": "ES6",
      "lib": ["ES2015", "DOM"],
      "module": "CommonJS"
    },
    "include": [
      "src/**/*.ts"
    ],
    "exclude": [
      "node_modules"
    ]
  }

```

```typescript

  $ tsc --watch
  
```

## TypeScript Playground

https://www.typescriptlang.org/play/index.html

타입스크립트 공식 페이지에서 제공하는 REPL로, 작성한 내용이 컴파일러 옵션에 따라 어떻게 자바스크립트로 변환되는지 바로 확인할 수 있습니다.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-playground.jpg" width = 90%></img></p>

## Repl.it

https://repl.it/languages/typescript

파일과 디렉터리로 관리되는 타입스크립트 프로젝트를 손쉽게 구성할 수 있습니다. <br />
간단한 프로젝트로 타입스크립트를 테스트하기 좋습니다. <br />

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-repl.jpg" width = 90%></img></p>

## Parcel

타입스크립트를 로컬 환경에서 빠르게 테스트하고 싶다면 [Parcel 번들러](https://ko.parceljs.org/getting_started.html)가 좋은 선택입니다. <br />
다음과 같이 간단하게 프로젝트를 구성합니다. <br />

```typescript
  
  $ mkdir typescript-test
  $ cd typescript-test
  $ npm init -y
  $ npm install -D typescript parcel-bundler

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-test-with-parcel-bundler.jpg" width = 90%></img></p>

<code>tsconfig.json</code> 파일을 생성하고 원하는 옵션을 추가합니다. <br />
다음은 예시입니다. <br />

```typescript

  {
    "compilerOptions": {
      "strict": true
    },
    "exclude": [
      "node_modules"
    ]
  }

```

<code>main.ts</code> 파일을 생성하고 원하는 타입스크립트 코드를 입력합니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  
  const sum: number = add(1, 2);
  console.log(sum);

```

<code>index.html</code> 파일을 생성하고 다음과 같이 <code>.js</code>가 아닌 <code>.ts</code> 파일을 연결합니다. <br />
Parcel 번들러가 빌드시 자동으로 타입스크립트를 컴파일합니다. <br />

```HTML

  <!doctype html>
  <html>
  <head>
    <meta charset="UTF-8">
    <title>TypeScript Test</title>
  </head>
  <body>
    <script src="main.ts"></script>
  </body>
  </html>

```

마지막으로 다음과 같이 진입 파일로 <code>index.html</code>를 지정하고 Parcel 번들러로 빌드합니다.

```typescript

  $ npx parcel index.html
  # Server running at http://localhost:1234

```

## TS Node

NodeJS 환경에서 테스트하고 싶다면 [TS Node](https://github.com/TypeStrong/ts-node)를 사용하세요. <br />
다음과 같이 간단하게 프로젝트를 구성합니다. <Br />

```text

  $ mkdir typescript-test
  $ cd typescript-test
  $ npm init -y
  $ npm install -D typescript @types/node ts-node

```

> [@types/node](https://github.com/DefinitelyTyped/DefinitelyTyped)는 Node.js API를 위한 타입 선언 모듈입니다.
> **@types**에 대한 자세한 내용은 ‘모듈’ 파트를 참고하세요.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-test-with-ts-node.jpg" width = 90%></img></p>

<code>tsconfig.json</code> 파일을 생성하고 원하는 옵션을 추가합니다. <br />
다음은 예시입니다. <br />

```json

  {
    "compilerOptions": {
      "strict": true,
      "module": "CommonJS"
    },
    "exclude": [
      "node_modules"
    ]
  }

```

<code>main.ts</code> 파일을 생성하고 원하는 타입스크립트 코드를 입력합니다.

```typescript

  console.log('TypeScript on NodeJS!');
  
```

TS Node를 사용해 <code>main.ts</code>를 실행합니다.

```typescript
  
  $ npx ts-node main.js
  # TypeScript on NodeJS!

```

# 타입 기본(Types)

## 타입 지정

타입스크립트는 일반 변수, 매개 변수(Parameter), 객체 속성(Property) 등에 : TYPE과 같은 형태로 타입을 지정할 수 있습니다.

```typescript

  function someFunc(a: TYPE_A, b: TYPE_B): TYPE_RETURN {
    return a + b;
  }
  let some: TYPE_SOME = someFunc(1, 2);
  
```

다음 예시를 보면,
<code>add</code> 함수의 매개 변수 <code>a</code>와 <code>b</code>는 <code>number</code> 타입이어야 한다고 지정했고,
그렇게 실행된 함수의 반환 값은 숫자로 추론(Inference)되기 때문에 변수 <code>sum</code>도 <code>number</code> 타입이어야 한다고 지정했습니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  const sum: number = add(1, 2);
  console.log(sum); // 3

```

자바스크립트로 컴파일한 결과는 다음과 같습니다.

```typescript

  "use strict";
  function add(a, b) {
    return a + b;
  }
  const sum = add(1, 2);
  console.log(sum);

```

## 타입 에러

만약 다음과 같이 변수 <code>sum</code>을 <code>number</code>가 아닌 <code>string</code> 타입이어야 한다고 지정했다면, 컴파일조차 하지 않고 코드를 작성하는 시점에서 에러가 발생합니다.

```typescript

  function add(a: number, b: number) {
    return a + b;
  }
  const sum: string = add(1, 2);
  console.log(sum);

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-error-ts2322.jpg" width = 90%></img></p>

위 이미지에서 [TS2322](https://www.google.com/search?newwindow=1&sxsrf=ACYBGNQeWU6z1K7DXQ9oM0VR4gV-KPSd2Q%3A1580379601357&ei=0a0yXpuyFZyCr7wPi96owAU&q=TS2322&oq=TS2322&gs_l=psy-ab.3..35i39j0j0i203l4j0j0i203l3.15216190.15216190..15216895...0.0..0.114.321.1j2......0....2j1..gws-wiz.......0i67j0i7i30j0i7i10i30j0i5i30j0i5i10i30.1W9DJiS_O3c&ved=0ahUKEwjb3v7ljKvnAhUcwYsBHQsvClgQ4dUDCAs&uact=5)라는 에러 코드를 볼 수 있으며, 이를 검색하면 쉽게 에러 코드에 대한 정보를 얻을 수 있습니다.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/search-typescript-error-code.jpg" width = 90%></img></p>

## 타입 선언

## 불린: Boolean

단순한 참(<code>true</code>)/거짓(<code>false</code>) 값을 나타냅니다.

```typescript

  let isBoolean: boolean;
  let isDone: boolean = false;

```

## 숫자: Number

모든 부동 소수점 값을 사용할 수 있습니다. <br />
ES6에 도입된 2진수 및 8진수 리터럴도 지원합니다. <br />

```typescript

  let num: number;
  let integer: number = 6;
  let float: number = 3.14;
  let hex: number = 0xf00d; // 61453
  let binary: number = 0b1010; // 10
  let octal: number = 0o744; // 484
  let infinity: number = Infinity;
  let nan: number = NaN;

```

## 문자열: String

문자열을 나타냅니다.
작은따옴표(<code>'</code>), 큰따옴표(<code>"</code>) 뿐만 아니라 ES6의 템플릿 문자열도 지원합니다.

```typescript
  
  let str: string;
  let red: string = 'Red';
  let green: string = "Green";
  let myColor: string = `My color is ${red}.`;
  let yourColor: string = 'Your color is' + green;

```

## 배열: Array

순차적으로 값을 가지는 일반 배열을 나타냅니다. <br />
배열은 다음과 같이 두 가지 방법으로 타입을 선언할 수 있습니다. <Br />


```typescript

  // 문자열만 가지는 배열
  let fruits: string[] = ['Apple', 'Banana', 'Mango'];
  // Or
  let fruits: Array<string> = ['Apple', 'Banana', 'Mango'];

  // 숫자만 가지는 배열
  let oneToSeven: number[] = [1, 2, 3, 4, 5, 6, 7];
  // Or
  let oneToSeven: Array<number> = [1, 2, 3, 4, 5, 6, 7];

```

유니언 타입(다중 타입)의 ‘문자열과 숫자를 동시에 가지는 배열’도 선언할 수 있습니다.

```typescript
  
  let array: (string | number)[] = ['Apple', 1, 2, 'Banana', 'Mango', 3];
  // Or
  let array: Array<string | number> = ['Apple', 1, 2, 'Banana', 'Mango', 3];

```

배열이 가지는 항목의 값을 단언할 수 없다면 <code>any</code>를 사용할 수 있습니다.

```typescript
  
  let someArr: any[] = [0, 1, {}, [], 'str', false];
  
```

인터페이스(Interface)나 커스텀 타입(Type)을 사용할 수도 있습니다.

```typescript

  interface IUser {
    name: string,
    age: number,
    isValid: boolean
  }
  let userArr: IUser[] = [
    {
      name: 'Neo',
      age: 85,
      isValid: true
    },
    {
      name: 'Lewis',
      age: 52,
      isValid: false
    },
    {
      name: 'Evan',
      age: 36,
      isValid: true
    }
  ];

```

유용하진 않지만, 다음과 같이 특정한 값으로 타입을 대신해 작성할 수도 있습니다.

```typescript

  let array = 10[];
  array = [10];
  array.push(10);
  array.push(11); // Error - TS2345

```

읽기 전용 배열을 생성할 수도 있습니다. <br />
<code>readonly</code> 키워드나 <code>ReadonlyArray</code> 타입을 사용하면 됩니다.

```typescript

  let arrA: readonly number[] = [1, 2, 3, 4];
  let arrB: ReadonlyArray<number> = [0, 9, 8, 7];

  arrA[0] = 123; // Error - TS2542: Index signature in type 'readonly number[]' only permits reading.
  arrA.push(123); // Error - TS2339: Property 'push' does not exist on type 'readonly number[]'.

  arrB[0] = 123; // Error - TS2542: Index signature in type 'readonly number[]' only permits reading.
  arrB.push(123); // Error - TS2339: Property 'push' does not exist on type 'readonly number[]'.

```

## 튜플: Tuple

Tuple 타입은 배열과 매우 유사합니다.
차이점이라면 **정해진 타입의 고정된 길이(length) 배열**을 표현합니다.

```typescript

  let tuple: [string, number];
  tuple = ['a', 1];
  tuple = ['a', 1, 2]; // Error - TS2322
  tuple = [1, 'a']; // Error - TS2322

```

다음과 같이 데이터를 개별 변수로 지정하지 않고, 단일 Tuple 타입으로 지정해 사용할 수 있습니다.

```typescript

  // Variables
  let userId: number = 1234;
  let userName: string = 'HEROPY';
  let isValid: boolean = true;

  // Tuple
  let user: [number, string, boolean] = [1234, 'HEROPY', true];
  console.log(user[0]); // 1234
  console.log(user[1]); // 'HEROPY'
  console.log(user[2]); // true

```

나아가 위 방식을 활용해 다음과 같은 Tuple 타입의 배열(2차원 배열)을 사용할 수 있습니다.

```typescript
  
  let users: [number, string, boolean][];
  // Or
  // let users: Array<[number, string, boolean]>;

  users = [[1, 'Neo', true], [2, 'Evan', false], [3, 'Lewis', true]];

```

역시 값으로 타입을 대신할 수도 있습니다.

```typescript

  let tuple: [1, number];
  tuple = [1, 2];
  tuple = [1, 3];
  tuple = [2, 3]; // Error - TS2322: Type '2' is not assignable to type '1'.

```

Tuple은 **정해진 타입의 고정된 길이 배열**을 표현하지만, 이는 할당(Assign)에 국한됩니다. <br />
<code>.push()</code>나 <code>.splice()</code> 등을 통해 값을 넣는 행위는 막을 수 없습니다. <br />

```typescript

  let tuple: [string, number];
  tuple = ['a', 1];
  tuple = ['b', 2];
  tuple.push(3);
  console.log(tuple); // ['b', 2, 3];
  tuple.push(true); // Error - TS2345: Argument of type 'true' is not assignable to parameter of type 'string | number'.

```

배열에서 사용한 것과 같이 <code>readonly</code> 키워드를 사용해 읽기 전용 튜플을 생성할 수도 있습니다.

```typescript

  let a: readonly [string, number] = ['Hello', 123];
  a[0] = 'World'; // Error - TS2540: Cannot assign to '0' because it is a read-only property.

```

## 열거형: Enum

Enum은 숫자 혹은 문자열 값 집합에 이름(Member)을 부여할 수 있는 타입으로, 값의 종류가 일정한 범위로 정해져 있는 경우 유용합니다. <Br />

기본적으로 <code>0</code>부터 시작하며 값은 <code>1</code>씩 증가합니다. <br />

```typescript
  
  enum Week {
    Sun,
    Mon,
    Tue,
    Wed,
    Thu,
    Fri,
    Sat
  }

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-enum-example1.jpg" width = 90%></img></p>

수동으로 값을 변경할 수 있으며, 값을 변경한 부분부터 다시 <code>1</code>씩 증가합니다.

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-enum-example2.jpg" width = 90%></img></p>

Enum 타입의 재미있는 부분은 역방향 매핑(Reverse Mapping)을 지원한다는 것입니다. <br />
이것은 열거된 멤버(<code>Sun</code>, <code>Mon</code> 같은)로 값에, 값으로 멤버에 접근할 수 있다는 것을 의미합니다. <br />

<code>Week</code>를 콘솔로 출력합니다.

```typescript

  enum Week {
    // ...
  }
  console.log(Week);
  console.log(Week.Sun); // 0
  console.log(Week['Sun']); // 0
  console.log(Week[0]); // 'Sun'

```

<p align = "center"><img src = "https://heropy.blog/images/screenshot/typescript/typescript-enum-console-log.jpg" width = 90%></img></p>

추가로, Enum은 숫자 값 열거뿐만아니라 다음과 같이 문자열 값으로 초기화할 수 있습니다. <br /> 
이 방법은 역방향 매핑(Reverse Mapping)을 지원하지 않으며 개별적으로 초기화해야 하는 단점이 있습니다. <br />

```typescript

  enum Color {
    Red = 'red',
    Green = 'green',
    Blue = 'blue'
  }
  console.log(Color.Red); // red
  console.log(Color['Green']); // green

```

## 모든 타입: Any

Any는 모든 타입을 의미합니다. <br />
따라서 일반적인 자바스크립트 변수와 동일하게 어떤 타입의 값도 할당할 수 있습니다. <br />
외부 자원을 활용해 개발할 때 불가피하게 타입을 단언할 수 없는 경우, 유용할 수 있습니다. <br />

```typescript

  let any: any = 123;
  any = 'Hello world';
  any = {};
  any = null;

```

다양한 값을 포함하는 배열을 나타낼 때 사용할 수도 있습니다.

```typescript

  const list: any[] = [1, true, 'Anything!'];
  
```

강한 타입 시스템의 장점을 유지하기 위해 Any 사용을 엄격하게 금지하려면, 컴파일 옵션 "noImplicitAny": true를 통해 Any 사용 시 에러를 발생시킬 수 있습니다.

## 알 수 없는 타입: Unknown

Any와 같이 최상위 타입인 Unknown은 알 수 없는 타입을 의미합니다. <br />
Any와 같이 Unknown에는 어떤 타입의 값도 할당할 수 있지만, Unknown을 다른 타입에는 할당할 수 없습니다. <br />

> 일반적인 경우 Unknown은 타입 단언(Assertions)이나 타입 가드(Guards)를 필요로 합니다. <Br/ >
> 타입 단언이나 가드에 대한 내용은 다른 파트에서 정리합니다.

```typescript

  let a: any = 123;
  let u: unknown = 123;

  let v1: boolean = a; // 모든 타입(any)은 어디든 할당할 수 있습니다.
  let v2: number = u; // 알 수 없는 타입(unknown)은 모든 타입(any)을 제외한 다른 타입에 할당할 수 없습니다.
  let v3: any = u; // OK!
  let v4: number = u as number; // 타입을 단언하면 할당할 수 있습니다.

```

다양한 타입을 반환할 수 있는 API에서 유용할 수 있습니다.

> Unknown 보단 좀 더 명확한 타입을 사용하는 것이 좋습니다.

```typescript

  type Result = {
    success: true,
    value: unknown
  } | {
    success: false,
    error: Error
  }

  export default function getItems(user: IUser): Result {
    // Some logic...
    if (id.isValid) {
      return {
        success: true,
        value: ['Apple', 'Banana']
      };
    } else {
      return {
        success: false,
        error: new Error('Invalid user.')
      }
    }
  }

```

## 객체: Object

기본적으로 <code>typeof</code> 연산자가 <code>"object"</code>로 반환하는 모든 타입을 나타냅니다.

> 컴파일러 옵션에서 엄격한 타입 검사(<code>strict</code>)를 <code>true</code>로 설정하면, <code>null</code>은 포함하지 않습니다.

```typescript

  let obj: object = {};
  let arr: object = [];
  let func: object = function () {};
  let nullValue: object = null;
  let date: object = new Date();
  // ...

```

여러 타입의 상위 타입이기 때문에 그다지 유용하지 않습니다. <br />
보다 정확하게 타입 지정을 하기 위해 다음과 같이 객체 속성(Properties)들에 대한 타입을 개별적으로 지정할 수 있습니다. <br />

```typescript

  let userA: { name: string, age: number } = {
    name: 'HEROPY',
    age: 123
  };

  let userB: { name: string, age: number } = {
    name: 'HEROPY',
    age: false, // Error
    email: 'thesecon@gmail.com' // Error
  };

```

반복적인 사용을 원하는 경우, <code>interface</code>나 <code>type</code>을 사용하는 것을 추천합니다.

```typescript

  interface IUser {
    name: string,
    age: number
  }

  let userA: IUser = {
    name: 'HEROPY',
    age: 123
  };

  let userB: IUser = {
    name: 'HEROPY',
    age: false, // Error
    email: 'thesecon@gmail.com' // Error
  };

```

## Null과 Undefined

기본적으로 Null과 Undefined는 모든 타입의 하위 타입으로, 다음과 같이 각 타입에 할당할 수 있습니다. <Br />
심지어 서로의 타입에도 할당 가능합니다. <br />

```typescript

  let num: number = undefined;
  let str: string = null;
  let obj: { a: 1, b: false } = undefined;
  let arr: any[] = null;
  let und: undefined = null;
  let nul: null = undefined;
  let voi: void = null;
  // ...

```

이는 컴파일 옵션 <code>"strictNullChecks": true</code>을 통해 엄격하게 Null과 Undefined 서로의 타입까지 더 이상 할당할 수 없게 합니다.
단, Void에는 Undefined를 할당할 수 있습니다.

```typescript

  let voi: void = undefined; // ok  

```

## Void

Void는 일반적으로 값을 반환하지 않는 함수에서 사용합니다. <br />
<code>: void</code> 위치는 함수가 반환 타입을 명시하는 곳입니다. <br />

```typesript

  function hello(msg: string): void {
    console.log(`Hello ${msg}`);
  }

```

값을 반환하지 않는 함수는 실제로는 <code>undefined</code>를 반환합니다.


```typescript

  function hello(msg: string): void {
    console.log(`Hello ${msg}`);
  }
  const hi: void = hello('world'); // Hello world
  console.log(hi); // undefined

```

```typescript

  // Error - TS2355: A function whose declared type is neither 'void' nor 'any' must return a value.
  function hello(msg: string): undefined {
    console.log(`Hello ${msg}`);
  }

```

## Never

Never은 **절대 발생하지 않을 값**을 나타내며, 어떠한 타입도 적용할 수 없습니다.

```typescript

   function error(message: string): never {
      throw new Error(message);
  }

```

보통 다음과 같이 빈 배열을 타입으로 잘못 선언한 경우, Never를 볼 수 있습니다.

```typescript

  const never: [] = [];
  never.push(3); // Error - TS2345: Argument of type '3' is not assignable to parameter of type 'never'.

```

## 유니언(Union)

2개 이상의 타입을 허용하는 경우, 이를 유니언(Union)이라고 합니다. <br />
<code>|</code>(vertical bar)를 통해 타입을 구분하며, ()는 선택 사항입니다. <br />

```typescript

  let union: (string | number);
  union = 'Hello type!';
  union = 123;
  union = false; // Error - TS2322: Type 'false' is not assignable to type 'string | number'.

```

## 인터섹션(Intersection)

<code>&</code>(ampersand)를 사용해 2개 이상의 타입을 조합하는 경우, 이를 인터섹션(Intersection)이라고 합니다. <br />
인터섹션은 새로운 타입을 생성하지 않고 기존의 타입들을 조합할 수 있기 때문에 유용하지만, 자주 사용되는 방법은 아닙니다. <Br />

> 위에서 살펴본 유니언을 마치 ‘또는(Or)’과 같이 이해할 수 있다면, 인터섹션은 ‘그리고(And)’와 같이 이해할 수 있습니다.

```typescript

  // 기존 타입들이 조합 가능하다면 인터섹션을 활용할 수 있습니다.
  interface IUser {
    name: string,
    age: number
  }
  interface IValidation {
    isValid: boolean
  }
  const heropy: IUser = {
    name: 'Heropy',
    age: 36,
    isValid: true // Error -  TS2322: Type '{ name: string; age: number; isValid: boolean; }' is not assignable to type 'IUser'.
  };
  const neo: IUser & IValidation = {
    name: 'Neo',
    age: 85,
    isValid: true
  };

  // 혹은 기존 타입(IUser, IValidation)과 비슷하지만, 정확히 일치하는 타입이 없다면 새로운 타입을 생성해야 합니다.
  interface IUserNew {
    name: string,
    age: number,
    isValid: boolean
  }
  const evan: IUserNew = {
    name: 'Evan',
    age: 36,
    isValid: false
  };

```

## 함수(Function)

화살표 함수를 이용해 타입을 지정할 수 있습니다. <br />
인수의 타입과 반환 값의 타입을 입력합니다. <br />

```typescript

  // myFunc는 2개의 숫자 타입 인수를 가지고, 숫자 타입을 반환하는 함수.
  let myFunc: (arg1: number, arg2: number) => number;
  myFunc = function (x, y) {
    return x + y;
  };

  // 인수가 없고, 반환도 없는 경우.
  let yourFunc: () => void;
  yourFunc = function () {
    console.log('Hello world~');
  };

```

## 타입 추론(Inference)

명시적으로 타입 선언이 되어있지 않은 경우, 타입스크립트는 타입을 추론해 제공합니다. <br />
개념은 매우 단순합니다. <br />

> [추론]: 어떠한 판단을 근거로 삼아 다른 판단을 이끌어 냄.

```typescript

  let num = 12;
  num = 'Hello type!'; // TS2322: Type '"Hello type!"' is not assignable to type 'number'.

```

변수 <code>num</code>을 초기화하면서 숫자 <code>12</code>를 할당해 Number 타입으로 추론되었고, 따라서 <code>'Hello type!'</code>이라는 String 타입의 값은 할당할 수 없기 때문에 에러가 발생합니다.

이렇게 타입스크립트가 타입을 추론하는 경우는 다음과 같습니다.

* 초기화된 변수
* 기본값이 설정된 매개 변수
* 반환 값이 있는 함수

```typescript

  // 초기화된 변수 `num`
  let num = 12;

  // 기본값이 설정된 매개 변수 `b`
  function add(a: number, b: number = 2): number {
    // 반환 값(`a + b`)이 있는 함수
    return a + b;
  }

```

> 타입 추론이 엄격하지 않은 타입 선언을 의미하는 것은 아닙니다. <br />
> 따라서 이를 활용해 모든 곳에 타입을 명시할 필요는 없으며, 많은 경우 더 좋은 코드 가독성을 제공할 수 있습니다. <br />

## 타입 단언(Assertions)

타입스크립트가 타입 추론을 통해 판단할 수 있는 타입의 범주를 넘는 경우, 더 이상 추론하지 않도록 지시할 수 있습니다. <Br />
이를 ‘타입 단언’이라고 하며, 이는 프로그래머가 타입스크립트보다 타입에 대해 더 잘 이해하고 있는 상황을 의미합니다. <br />

> [단언]: 주저하지 아니하고 딱 잘라 말함.

다음 예제를 살펴봅시다. <br />

함수의 매개 변수 <code>val</code>은 유니언 타입으로 문자열(String)이거나 숫자(Number)일 수 있습니다. <br />
그리고 매개 변수 <code>isNumber</code>는 불린(Boolean)이며, 이름을 통해 숫자 여부를 확인하는 값이라는 것을 (우리는) 추론할 수 있습니다. <br />
따라서 우리는 <code>isNumber</code>가 true일 경우 val은 숫자일 것이고, 이에 toFixed를 사용할 수 있음을 확실히 알 수 있습니다. <br />
하지만 타입스크립트는 ‘isNumber’라는 이름만으로 위 내용을 추론할 수 없기 때문에 “<code>val</code>이 문자열인 경우 <code>toFixed</code>를 사용할 수 없다”고 (컴파일 단계에서) 다음과 같은 에러를 반환합니다. <br />

```typescript

  function someFunc(val: string | number, isNumber: boolean) {
    // some logics
    if (isNumber) {
      val.toFixed(2); // Error - TS2339: ... Property 'toFixed' does not exist on type 'string'.
    }
  }

```

따라서 우리는 <code>isNumber</code>가 <code>true</code>일 때 <code>val</code>이 숫자임을 다음과 같이 2가지 방식으로 단언할 수 있습니다. <br />
두 번째 방식(<code>`<number>`val</code>)은 JSX를 사용하는 경우 특정 구문 파싱에서 문제가 발생할 수 있으며, 결과적으로 <Code>.tsx</code> 파일에서는 전혀 사용할 수 없습니다. <br />

```typescript
  
  function someFunc(val: string | number, isNumber: boolean) {
    // some logics
    if (isNumber) {
      // 1. 변수 as 타입
      (val as number).toFixed(2);
      // Or
      // 2. <타입>변수
      // (<number>val).toFixed(2);
    }
  }

```

> 타입 단언은 마치 프로그래머가 타입스크립트에게 “나는 알고 있으니까 나를 믿어!”라고 알려주는 것과 같습니다.

## Non-null 단언 연산자

<code>!</code>를 사용하는 Non-null 단언 연산자(Non-null assertion operator)를 통해 피연산자가 Nullish(<code>null</code>이나 <code>undefined</code>) 값이 아님을 단언할 수 있는데, 변수나 속성에서 간단하게 사용할 수 있기 때문에 유용합니다.

다음 예제 중 <code>fnA</code> 함수를 살펴보면, 매개 변수 <code>x</code>는 함수 내에서 <code>toFixed</code>를 사용하는 숫자 타입으로 처리되지만 <code>null</code>이나 <code>undefined</code>일 수 있기 때문에 에러가 발생합니다.
이를 타입 단언이나 <code>if</code> 조건문으로 해결할 수도 있지만, 마지막 함수와 같이 <code>!</code>를 사용하는 Non-null 단언 연산자를 이용해 간단하게 정리할 수 있습니다.

```typescript
  
  // Error - TS2533: Object is possibly 'null' or 'undefined'.
  function fnA(x: number | null | undefined) {
    return x.toFixed(2);
  }

  // if statement
  function fnD(x: number | null | undefined) {
    if (x) {
      return x.toFixed(2);
    }
  }

  // Type assertion
  function fnB(x: number | null | undefined) {
    return (x as number).toFixed(2);
  }
  function fnC(x: number | null | undefined) {
    return (<number>x).toFixed(2);
  }

  // Non-null assertion operator
  function fnE(x: number | null | undefined) {
    return x!.toFixed(2);
  }

```

특히 컴파일 환경에서 체크하기 어려운 DOM 사용에서 유용합니다. <br />
물론 일반적인 타입 단언을 사용할 수도 있습니다. <Br />

```typescript

  // Error - TS2531: Object is possibly 'null'.
  document.querySelector('.menu-item').innerHTML;

  // Type assertion
  (document.querySelector('.menu-item') as HTMLDivElement).innerHTML;
  (<HTMLDivElement>document.querySelector('.menu-item')).innerHTML;

  // Non-null assertion operator
  document.querySelector('.menu-item')!.innerHTML;

```

## 타입 가드(Guards)

다음 예제와 같이 <code>val</code>의 타입을 매번 보장하기 위해 타입 단언을 여러 번 사용하게 되는 경우가 있습니다.

```typescript
  
  function someFunc(val: string | number, isNumber: boolean) {
    if (isNumber) {
      (val as number).toFixed(2);
      isNaN(val as number);
    } else {
      (val as string).split('');
      (val as string).toUpperCase();
      (val as string).length;
    }
  }

```

이 경우 타입 가드를 제공하면 타입스크립트가 추론 가능한 특정 범위(scope)에서 타입을 보장할 수 있습니다.
타입 가드는 <code>NAME is TYPE</code> 형태의 **타입 술부(Predicate)** 를 반환 타입으로 명시한 함수입니다.
다음 예제에서 타입 술부는 <code>val is number</code>입니다.
타입 단언이 없어지니 훨씬 깔끔합니다.

> [술부]: 주어의 상태, 성질 따위를 서술하는 말.

```typescript

  // 타입 가드
  function isNumber(val: string | number): val is number {
    return typeof val === 'number';
  }

  function someFunc(val: string | number) {
    if (isNumber(val)) {
      val.toFixed(2);
      isNaN(val);
    } else {
      val.split('');
      val.toUpperCase();
      val.length;
    }
  }

```

위 방식뿐만 아니라 제공 가능한 타입 가드가 더 있습니다. <br />
<code>typeof</code>, <code>in</code> 그리고 <code>instanceof</code> 연산자를 직접 사용하는 타입 가드입니다. <br />
비교적 단순한 로직에서 추천되는 방식입니다. <br />

> <code>typeof</code> 연산자는 <code>number</code>, <code>string</code>, <code>boolean</code>, 그리고 <code>symbol</code>만 타입 가드로 인식할 수 있습니다. <br />
> <code>in</code> 연산자의 우변 객체(<code>val</code>)는 <code>any</code> 타입이어야 합니다.

```typescript

  // 기존 예제와 같이 `isNumber`를 제공(추상화)하지 않아도 `typeof` 연산자를 직접 사용하면 타입 가드로 동작합니다.
  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/typeof
  function someFuncTypeof(val: string | number) {
    if (typeof val === 'number') {
      val.toFixed(2);
      isNaN(val);
    } else {
      val.split('');
      val.toUpperCase();
      val.length;
    }
  }

  // 별도의 추상화 없이 `in` 연산자를 사용해 타입 가드를 제공합니다.
  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/in
  function someFuncIn(val: any) {
    if ('toFixed' in val) {
      val.toFixed(2);
      isNaN(val);
    } else if ('split' in val) {
      val.split('');
      val.toUpperCase();
      val.length;
    }
  }

  // 역시 별도의 추상화 없이 `instanceof` 연산자를 사용해 타입 가드를 제공합니다.
  // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/instanceof
  class Cat {
    meow() {}
  }
  class Dog {
    woof() {}
  }
  function sounds(ani: Cat | Dog) {
    if (ani instanceof Cat) {
      ani.meow();
    } else {
      ani.woof();
    }
  }

```

## 인터페이스(interface)

인터페이스(Interface)는 타입스크립트 여러 객체를 정의하는 일종의 규칙이며 구조입니다. <br />
다음과 같이 <code>interface</code> 키워드와 함께 사용합니다. <br />

> ‘IUser’에서 ‘I’는 Interface를 의미하는 별칭으로 사용했습니다.

```typescript

  interface IUser {
    name: string,
    age: number,
    isAdult: boolean
  }

  let user1: IUser = {
    name: 'Neo',
    age: 123,
    isAdult: true
  };

  // Error - TS2741: Property 'isAdult' is missing in type '{ name: string; age: number; }' but required in type 'IUser'.
  let user2: IUser = {
    name: 'Evan',
    age: 456
  };

```

<code>:</code>(colon), <code>,</code>(comma) 혹은 기호를 사용하지 않을 수 있습니다.

```typescript
  
  interface IUser {
    name: string,
    age: number
  }
  // Or
  interface IUser {
    name: string;
    age: number;
  }
  // Or
  interface IUser {
    name: string
    age: number
  }

```

다음과 같이 속성에 <code>?</code>를 사용하면 선택적 속성으로 정의할 수 있습니다.<br .>
선택적 속성(Optional properties)에 대해선 Optional 파트에서 따로 설명하지만, <br />
간단하게 표현하면 ‘필수가 아닌 속성으로 정의’하는 방법을 말합니다. 

```typescript

  interface IUser {
    name: string,
    age: number,
    isAdult?: boolean // Optional property
  }

  // `isAdult`를 초기화하지 않아도 에러가 발생하지 않습니다.
  let user: IUser = {
    name: 'Neo',
    age: 123
  };

````

## 읽기 전용 속성(Readonly properties)

<code>readonly</code> 키워드를 사용하면 초기화된 값을 유지해야 하는 **읽기 전용 속성을 정의**할 수 있습니다.

```typescript

  
  interface IUser {
    readonly name: string,
    age: number
  }

  // 초기화
  let user: IUser = {
    name: 'Neo',
    age: 36
  };

  user.age = 85; // Ok
  user.name = 'Evan'; // Error - TS2540: Cannot assign to 'name' because it is a read-only property.

```

만약 모든 속성이 <code>readonly</code>일 경우, [유틸리티(Utility)](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlyt)나 단언(Assertion) 타입을 활용할 수 있습니다.

```typescript

  // All readonly properties
  interface IUser {
    readonly name: string,
    readonly age: number
  }
  let user: IUser = {
    name: 'Neo',
    age: 36
  };
  user.age = 85; // Error
  user.name = 'Evan'; // Error


  // Readonly Utility
  interface IUser {
    name: string,
    age: number
  }
  let user: Readonly<IUser> = {
    name: 'Neo',
    age: 36
  };
  user.age = 85; // Error
  user.name = 'Evan'; // Error


  // Type assertion
  let user = {
    name: 'Neo',
    age: 36
  } as const;
  user.age = 85; // Error
  user.name = 'Evan'; // Error

```

## 함수 타입

함수 타입을 인터페이스로 정의하는 경우, 호출 시그니처(Call signature)라는 것을 사용합니다. <br />
호출 시그니처는 다음과 같이 함수의 매개 변수(parameter)와 반환 타입을 지정합니다. <Br />

```typescript

  interface IName {
    (PARAMETER: PARAM_TYPE): RETURN_TYPE // Call signature
  }

```

간단한 예시를 살펴봅시다. <Br />

인터페이스 <code>IGetUser</code>를 통해 함수 타입을 정의했으며, 이는 <code>name</code> 매개 변수를 하나 가지며(이름이 일치할 필요는 없습니다), <br />
<code>IUser</code> 타입을 반환해야 합니다.

```typescript

  interface IUser {
    name: string
  }
  
  interface IGetUser {
    (name: string): IUser
  }

  // 매개 변수 이름이 인터페이스와 일치할 필요가 없습니다.
  // 또한 타입 추론을 통해 매개 변수를 순서에 맞게 암시적 타입으로 제공할 수 있습니다.
  const getUser: IGetUser = function (n) { // n is name: string
    // Find user logic..
    // ...
    return user;
  };
  getUser('Heropy');

```

## 클래스 타입

인터페이스로 클래스를 정의하는 경우, <code>implements</code> 키워드를 사용합니다.

```typescript
  
  interface IUser {
    name: string,
    getName(): string
  }

  class User implements IUser {
    constructor(public name: string) {}
    getName() {
      return this.name;
    }
  }

  const neo = new User('Neo');
  neo.getName(); // Neo

```

기본적인 사용법은 어렵지 않습니다. <br />
그런데 만약 정의한 클래스를 인수로 사용하는 경우 다음과 같은 문제가 발생할 수 있습니다. <br />
다음 예제에서 인터페이스 <code>ICat</code>은 호출 가능한 구조가 아니기 때문입니다. <br />

```typescript
  
  interface ICat {
    name: string
  }

  class Cat implements ICat {
    constructor(public name: string) {}
  }

  function makeKitten(c: ICat, n: string) {
    return new c(n); // Error - TS2351: This expression is not constructable. Type 'ICat' has no construct signatures.
  }
  const kitten = makeKitten(Cat, 'Lucy');
  console.log(kitten);

```

이를 위해 구성 시그니처(Construct signature)를 제공할 수 있습니다.
구성 시그니처는 위에서 살펴본 호출 시그니처와 비슷하지만, <code>new</code> 키워드를 사용해야 합니다.

```typescript
  
  interface IName {
    new (PARAMETER: PARAM_TYPE): RETURN_TYPE // Construct signature
  }

```

위에서 봤던 예제를 다음과 같이 수정합니다.<br />
<code>ICatConstructor</code>라는 구성 시그니처를 가지는 호출 가능한 인터페이스를 정의하면, 문제없이 동작하는 것을 확인할 수 있습니다. <br />

```typescript

  interface ICat {
    name: string
  }
  interface ICatConstructor {
    new (name: string): ICat;
  }

  class Cat implements ICat {
    constructor(public name: string) {}
  }

  function makeKitten(c: ICatConstructor, n: string) {
    return new c(n); // ok
  }
  const kitten = makeKitten(Cat, 'Lucy');
  console.log(kitten);

```

비슷하지만 좀 더 재미있는 예제를 준비했습니다. <br />
에러가 발생하는 부분을 확인하고 내용을 이해했다면 충분합니다. <br />

```typescript
  
  interface IFullName {
    firstName: string,
    lastName: string
  }
  interface IFullNameConstructor {
    new(firstName: string): IFullName; // Construct signature
  }


  function makeSon(c: IFullNameConstructor, firstName: string) {
    return new c(firstName);
  }
  function getFullName(son: IFullName) {
    return `${son.firstName} ${son.lastName}`;
  }


  // Anderson family
  class Anderson implements IFullName {
    public lastName: string;
    constructor (public firstName: string) {
      this.lastName = 'Anderson';
    }
  }
  const tomas = makeSon(Anderson, 'Tomas');
  const jack = makeSon(Anderson, 'Jack');
  getFullName(tomas); // Tomas Anderson
  getFullName(jack); // Jack Anderson


  // Smith family?
  class Smith implements IFullName {
    public lastName: string;
    constructor (public firstName: string, agentCode: number) {
      this.lastName = `Smith ${agentCode}`;
    }
  }
  const smith = makeSon(Smith, 7); // Error - TS2345: Argument of type 'typeof Smith' is not assignable to parameter of type 'IFullNameConstructor'.
  getFullName(smith);

```

저 코드에서 에러가 나는 이유는 makeSon의 첫번째 파라미터는 IFullNameConstructor 타입이라야 하는데, Smith는 타입을 만족하지 못하기 때문입니다.<br /> 
IFullNameConstructor 정의를 보시면 firstName을 받아서 IFullName 오브젝트를 리턴하는 컨스트럭터가 있어야 하는데, Smith 컨스트럭터는 (string, number)을 받아서 IFullName을 리턴합니다. <br />
Anderson 클래스 넣어보시면 작동하는거 [확인](https://typescript-play.js.org/?fbclid=IwAR3Vmd0DE9y0gMhAIhJRGr2NthNiA5Z_PMqOAGzJAP3iY_oKwOozKsxWNkE#code/JYOwLgpgTgZghgYwgAgJIDECuAbbA5OAWxQG8AoM5K5GYKAZzAOIC5lGpQBzAGguuTY4jZhDYduFAL4VQkWIhQYc+IhADCAexAdMCMJqjJylaiAgB3ABS0GTNeLCcQXAJRtluUQG5kAej9kLR0nPTB2YC4QODBMKAhpChhMEH1gbWRCOABrCABlbSsEDywvNWDdfUMeGjoRB3Ynbldjfmp42KgQZHMLZAQbOvtiV29EsmTUsHTurggwUtViK3ptEpVRFpMBDrjugAMAEhJVkAA6W3riKWRj07OhK4gpfbGyGTIA5ABBEAATaCnGhEYDYACeFAQj3oP3+gIywEIAAdsBBiOAYZ4lqQ2lQkZgAEbYYAIQTCYZiRrOLhvAQIbSVAxQKz4okk2p2USOalbXECZBgAAWwHoD3JomQAF5kAByX4AhjaGW06gfD70kICzRZGHSrK5AogKzy+EgGoygAq2uEMtGkIZ4QAVohslLMjl8oUTYqzbKAFIu21vOYLDZqKwGHWjfyBK062EK04UEOLURWZ0IbLRr4BzMJ00UL55QjAIXAkvggD8kOhyGLpcFyERKLREAxaFTalapjxhOJpMeFO53BVVA1jMMLL77MuQ6pzVa-OoqPCcDm4C0ALdAGZR-yhSKxU83ft62Xjmu22BN89Xny1fbNY7NCg9R7Dca4T6agAiP0vn87TIcdNFRB5NC4KwUzDZZnwgVxRiAA) 가능힙니다. <br />

즉, 쉽게 말해서 Anderson의 생성자는 IFullNameConstructor을 만족하고, Smith 의 생성자는 IFullNameConstructor를 만족하지 못하는 클래스라서 그런 것이므로<br />
 Smith 생성자를 만족하는 IFullName,FullNameConstructor를 추가로 만들거나, 옵셔날을 주면 되겠지만 
 인터페이스를 만드는 이유는 서로 다른 class를 섞어서 쓰기 위함입니다. <br /> 
 예제에서는 Smith와 Anderson을 둘 다 makeSon에서 써도 되도록 IFullName과 IFullNameConstructor 인터페이스를 만든 것이라고 보여집니다. <br />
 그러므로 agentCode를 옵셔널로 바꿔서 Smith를 IFullNameConstructor에 맞추는것이 가장 적절한 해결책이라고 보여집니다. <br />
 기존 Smith 클라스에 맞춰서 새로운 인터페이스를 만드는건 목적에 어긋나는것 같습니다.<br />

## 인덱싱 가능 타입(Indexable types)

우리는 인터페이스를 통해 특정 속성(메소드 등)의 타입을 정의할 순 있지만, 수많은 속성을 가지거나 단언할 수 없는 임의의 속성이 포함되는 구조에서는 기존의 방식만으론 한계가 있습니다. <Br />
이런 상황에서 유용한 인덱스 시그니처(Index signature)에 대해서 살펴봅시다. <br />

<code>arr[2]</code>와 같이 ‘숫자’로 인덱싱하거나 <code>obj['name']</code>과 같이 ‘문자’로 인덱싱하는, 인덱싱 가능 타입(Indexable types)들이 있습니다. <br />

이런 인덱싱 가능 타입들을 정의하는 인터페이스는 인덱스 시그니처(Index signature)라는 것을 가질 수 있습니다. <br />
인덱스 시그니처는 다음 구조와 같이, 인덱싱에 사용할 인덱서(Indexer)의 이름과 타입 그리고 인덱싱 결과의 반환 값을 지정합니다. <br />

**인덱서의 타입은 <code>string</code>과 <code>number</code>만 지정**할 수 있습니다.

```typescript

  interface INAME {
    [INDEXER_NAME: INDEXER_TYPE]: RETURN_TYPE // Index signature
  }

```

> 배열(객체)에서 위치를 가리키는 숫자(문자)를 인덱스(index)라고 하며, <Br />
> 각 배열 요소(객체 속성)에 접근하기 위하여 인덱스를 사용하는 것을 인덱싱(indexing)이라고 합니다. <br />
> (배열을 구성하는 각각의 값은 배열 요소(element)라고 합니다) <br />

이해를 돕기 위해 다음 예제를 살펴보면,<br />
인터페이스 <code>IItem</code>은 인덱스 시그니처를 가지고 있으며, 그 <code>IItem</code>을 타입(인터페이스)으로 하는 <code>item</code>이 있고, <br/>
그 <code>item</code>을 <code>item[0]</code>이나 <code>item[1]</code>과 같이 숫자로 인덱싱할 때 반환되는 값은 <code>'a'</code>나 <code>'b'</code> 같은 문자여야 합니다. <br />
<code>item</code>을 <code>item['0']</code>과 같이 문자로 인덱싱하는 경우 에러가 발생합니다. <Br />

```typescript

  interface IItem {
    [itemIndex: number]: string // Index signature
  }
  let item: IItem = ['a', 'b', 'c']; // Indexable type
  console.log(item[0]); // 'a' is string.
  console.log(item[1]); // 'b' is string.
  console.log(item['0']); // Error - TS7015: Element implicitly has an 'any' type because index expression is not of type 'number'.

```

참고로 인덱싱 결과의 반환 타입으로 유니온을 사용하면 다음과 같이 활용할 수 있습니다.

```typescript
  
  interface IItem {
    [itemIndex: number]: string | boolean | number[]
  }
  let item: IItem = ['Hello', false, [1, 2, 3]];
  console.log(item[0]); // Hello
  console.log(item[1]); // false
  console.log(item[2]); // [1, 2, 3]

```

이번에는 문자로 인덱싱하는 예제를 살펴봅시다. <br />

인터페이스 <code>IUser</code>는 인덱스 시그니처를 가지고 있으며, 그 <code>IUser</code>를 타입(인터페이스)로 하는 <code>user</code>가 있고, <br />
그 <code>user</code>를 <code>user['name']</code>, <code>user['email']</code> 또는 <code>user['isValid']</code>와 같이 문자로 인덱싱할 때 <Br />
반환되는 값은 <code>'Neo'</code>나 <code>'thesecon@gmail.com'</code> 같은 문자 혹은 true 같은 불린이어야 합니다. <br />
또한 <code>user[0]</code>과 같은 숫자로 인덱싱하는 경우나 <code>user['0']</code>과 같이 문자로 인덱싱하는 경우 모두 인덱싱 전에 숫자가 문자열로 변환되기 때문에 다음과 같이 값을 반환할 수 있습니다. <br />

```typescript

  interface IUser {
    [userProp: string]: string | boolean
  }
  let user: IUser = {
    name: 'Neo',
    email: 'thesecon@gmail.com',
    isValid: true,
    0: false
  };
  console.log(user['name']); // 'Neo' is string.
  console.log(user['email']); // 'thesecon@gmail.com' is string.
  console.log(user['isValid']); // true is boolean.
  console.log(user[0]); // false is boolean
  console.log(user[1]); // undefined
  console.log(user['0']); // false is boolean

```

인덱스 시그니처를 사용하면 다음 예제와 같이 인터페이스에 정의되지 않은 속성들을 사용할 때 유용합니다. <br />
단, 해당 속성이 인덱스 시그니처에 정의된 반환 값을 가져야 함에 주의해야 합니다. <br />
다음 예제에서 <code>isAdult</code> 속성은 정의된 <code>string</code>이나 <code>number</code> 타입을 반환하지 않지 않기 때문에 에러가 발생합니다. <br />

```typescript

  interface IUser {
    [userProp: string]: string | number
    name: string,
    age: number
  }
  let user: IUser = {
    name: 'Neo',
    age: 123,
    email: 'thesecon@gmail.com',
    isAdult: true // Error - TS2322: Type 'true' is not assignable to type 'string | number'.
  };
  console.log(user['name']); // 'Neo'
  console.log(user['age']); // 123
  console.log(user['email']); // thesecon@gmail.com

```

## keyof

인덱싱 가능 타입에서 <code>keyof</code>를 사용하면 속성 이름을 타입으로 사용할 수 있습니다. <br />
인덱싱 가능 타입의 속성 이름들이 **유니온 타입으로 적용**됩니다. <br />
간단한 예제를 살펴보겠습니다. <br />

```typescript

  interface ICountries {
    KR: '대한민국',
    US: '미국',
    CP: '중국'
  }
  let country: keyof ICountries; // 'KR' | 'US' | 'CP'
  country = 'KR'; // ok
  country = 'RU'; // Error - TS2322: Type '"RU"' is not assignable to type '"KR" | "US" | "CP"'.

```

또한 <code>keyof</code>를 통한 인덱싱으로 타입의 개별 값에도 접근할 수 있습니다.

```typescript
  
  interface ICountries {
    KR: '대한민국',
    US: '미국',
    CP: '중국'
  }
  let country: ICountries[keyof ICountries]; // ICountries['KR' | 'US' | 'CP']
  country = '대한민국';
  country = '러시아'; // Error - TS2322: Type '"러시아"' is not assignable to type '"대한민국" | "미국" | "중국"'.

```

## 인터페이스 확장

인터페이스도 클래스처럼 <code>extends</code> 키워드를 활용해 상속할 수 있습니다.

```typescript

  interface IAnimal {
    name: string
  }
  interface ICat extends IAnimal {
    meow(): string
  }

  class Cat implements ICat { // Error - TS2420: Class 'Cat' incorrectly implements interface 'ICat'. Property 'name' is missing in type 'Cat' but required in type 'ICat'.
    meow() {
      return 'MEOW~'
    }
  }

``

그리고 같은 이름의 인터페이스를 여러 개 만들 수도 있습니다. <br />
기존에 만들어진 인터페이스에 내용을 추가하는 경우에 유용합니다. <Br />

```typescript
  
  interface IFullName {
    firstName: string,
    lastName: string
  }
  interface IFullName {
    middleName: string
  }

  const fullName: IFullName = {
    firstName: 'Tomas',
    middleName: 'Sean',
    lastName: 'Connery'
  };

```

## 타입 별칭(Type Aliases)

<code>type</code> 키워드를 사용해 새로운 타입 조합을 만들 수 있습니다. <br />
하나 이상의 타입을 조합해 별칭(이름)을 부여하며, 정확히는 조합한 각 타입들을 참조하는 별칭을 만드는 것입니다. <br />
일반적인 경우 둘 이상의 조합으로 구성하기 위해 유니온을 많이 사용합니다. <br />

> TUser에서 T는 Type를 의미하는 별칭으로 사용했습니다.

```typscript
  
  type MyType = string;
  type YourType = string | number | boolean;
  type TUser = {
    name: string,
    age: number,
    isValid: boolean
  } | [string, number, boolean];

  let userA: TUser = {
    name: 'Neo',
    age: 85,
    isValid: true
  };
  let userB: TUser = ['Evan', 36, false];

  function someFunc(arg: MyType): YourType {
    switch (arg) {
      case 's':
        return arg.toString(); // string
      case 'n':
        return parseInt(arg); // number
      default:
        return true; // boolean
    }
  }

```

## 제네릭(Generic)

Generic은 재사용을 목적으로 함수나 클래스의 선언 시점이 아닌, **사용 시점에 타입을 선언할 수 있는 방법**을 제공합니다.

> 타입을 인수로 받아서 사용한다고 이해하면 쉽습니다.

다음 예제는 <code>toArray</code> 함수가 인수로 받은 값을 배열로 반환하도록 작성되었습니다.
매개 변수가 Number 타입만 허용하기 때문에 String 타입을 인수로 하는 함수 호출에서 에러가 발생합니다.

```typescript
  
  function toArray(a: number, b: number): number[] {
    return [a, b];
  }
  toArray(1, 2);
  toArray('1', '2'); // Error - TS2345: Argument of type '"1"' is not assignable to parameter of type 'number'.

```

조금 더 범용적으로 만들기 위해 유니언 방식을 사용했습니다. <Br />
이제 String 타입을 인수로 받을 수 있지만, 가독성이 떨어지고 새로운 문제도 발생했습니다. <br />
세 번째 호출을 보면 의도치 않게 Number와 String 타입을 동시에 받을 수 있게 되었습니다. <br />

```typescript
  
  function toArray(a: number | string, b: number | string): (number | string)[] {
    return [a, b];
  }
  toArray(1, 2); // Only Number
  toArray('1', '2'); // Only String
  toArray(1, '2'); // Number & String

```

이번에는 Generic을 사용합니다. <br />
함수 이름 우측에 <code><T></code>를 작성해 시작합니다. <br />
<code>T</code>는 타입 변수(Type variable)로 사용자가 제공한 타입으로 변환될 식별자입니다. <br />
이제 세 번째 호출은 의도적으로 Number와 String 타입을 동시에 받을 수 있습니다.(혹은 유니언을 사용하지 않으면 에러가 발생합니다) <br />

> 타입 변수는 매개 변수처럼 원하는 이름으로 지정할 수 있습니다.

```typescript
  
  function toArray<T>(a: T, b: T): T[] {
    return [a, b];
  }

  toArray<number>(1, 2);
  toArray<string>('1', '2');
  toArray<string | number>(1, '2');
  toArray<number>(1, '2'); // Error
  
```

타입 추론을 활용해, 사용 시점에 타입을 제공하지 않을 수 있습니다.

```typescript
  
  function toArray<T>(a: T, b: T): T[] {
    return [a, b];
  }

  toArray(1, 2);
  toArray('1', '2');
  toArray(1, '2'); // Error
  
```

## 제약 조건(Constraints)

인터페이스나 타입 별칭을 사용하는 제네릭을 작성할 수도 있습니다. <br />
다음 예제는 별도의 제약 조건(Constraints)이 없어서 모든 타입이 허용됩니다. <br />

```typescript 

  interface MyType<T> {
    name: string,
    value: T
  }

  const dataA: MyType<string> = {
    name: 'Data A',
    value: 'Hello world'
  };
  const dataB: MyType<number> = {
    name: 'Data B',
    value: 1234
  };
  const dataC: MyType<boolean> = {
    name: 'Data C',
    value: true
  };
  const dataD: MyType<number[]> = {
    name: 'Data D',
    value: [1, 2, 3, 4]
  };

```

만약 타입 변수 <code>T</code>가 <code>string</code>과 <code>number</code>인 경우만 허용하려면 아래 예제와 같이 <code>extends</code> **키워드를 사용하는 제약 조건**을 추가할 수 있습니다. <br />
기본 문법은 다음과 같습니다.

```typescript

  T extends U
  
```

```typescript

  interface MyType<T extends string | number> {
    name: string,
    value: T
  }

  const dataA: MyType<string> = {
    name: 'Data A',
    value: 'Hello world'
  };
  const dataB: MyType<number> = {
    name: 'Data B',
    value: 1234
  };
  const dataC: MyType<boolean> = { // TS2344: Type 'boolean' does not satisfy the constraint 'string | number'.
    name: 'Data C',
    value: true
  };
  const dataD: MyType<number[]> = { // TS2344: Type 'number[]' does not satisfy the constraint 'string | number'.
    name: 'Data D',
    value: [1, 2, 3, 4]
  };

```

대표적으로 <code>type</code>과 <code>interface</code> 키워드를 사용하는 타입 선언은 다음 예제와 같이 <code>=</code> 기호를 기준으로 ‘식별자’와 ‘타입 구현’으로 구분할 수 있습니다. <br />
제약 조건은 ‘식별자’ 영역에서 사용하는 <code>extends</code>에 한합니다.

```typescript
  
  type U = string | number | boolean;

  // type 식별자 = 타입 구현
  type MyType<T extends U> = string | T;

  // interface 식별자 { 타입 구현 }
  interface IUser<T extends U> {
    name: string,
    age: T
  }

```

## 조건부 타입(Conditional Types)

제약 조건과 다르게 ‘타입 구현’ 영역에서 사용하는 <code>extends</code>는 삼항 연산자(Conditional ternary operator)를 사용할 수 있습니다.
이를 조건부 타입(Conditional Types)이라고 하며 다음과 같은 문법을 가집니다.

```typescript
  
  T extends U ? X : Y
  
```

```typescript
  
  type U = string | number | boolean;

  // type 식별자 = 타입 구현
  type MyType<T> = T extends U ? string : never;

  // interface 식별자 { 타입 구현 }
  interface IUser<T> {
    name: string,
    age: T extends U ? number : never
  }
  
```

```typescript
  
  // `T`는 `boolean` 타입으로 제한.
  interface IUser<T extends boolean> {
    name: string,
    age: T extends true ? string : number, // `T`의 타입이 `true`인 경우 `string` 반환, 아닌 경우 `number` 반환.
    isString: T
  }

  const str: IUser<true> = {
    name: 'Neo',
    age: '12', // String
    isString: true
  }
  
  const num: IUser<false> = {
    name: 'Lewis',
    age: 12, // Number
    isString: false
  }
  
```

다음과 같이 삼항 연산자를 연속해서 사용할 수도 있습니다.

```typescript

  type MyType<T> =
    T extends string ? 'Str' :
    T extends number ? 'Num' :
    T extends boolean ? 'Boo' :
    T extends undefined ? 'Und' :
    T extends null ? 'Nul' :
    'Obj';

```

## infer

<code>infer</code> 키워드를 사용해 **타입 변수의 타입 추론(Inference)** 여부를 확인할 수 있습니다.
기본 문법은 다음과 같습니다.

<code>U</code>가 추론 가능한 타입이면 참, 아니면 거짓

```typescript
  
  T extends infer U ? X : Y
  
```

유용하진 않지만, 이해를 위한 아주 간단한 예제를 살펴봅시다. <br />
기본 구조는 위에서 살펴본 조건부 타입과 같습니다. <br />

```typescript

  type MyType<T> = T extends infer R ? R : null;

  const a: MyType<number> = 123;

```

여기서 타입 변수 <code>R<code>은 <code>MyType`<number>`</code>에서 받은 타입 <code>number</code>가 되고 <code>infer</code> 키워드를 통해 타입 추론이 가능한지 확인합니다.<br />
<code>number</code> 타입은 당연히 타입 추론이 가능하니 <code>R</code>을 반환하게 됩니다.(만약 <code>R</code>을 타입 추론할 수 없다면 <code>null</code>이 반환됩니다) <br />
결과적으로 <code>MyType`<number>`</code>는 <code>number</code>를 반환하고 변수 <code>a</code>는 <code>123</code>을 할당할 수 있습니다.

이번에는 조금 더 복잡하지만 유용한 예제를 하나 살펴봅시다. <br />
<code>ReturnType</code>는 함수의 반환 값이 어떤 타입인지 반환합니다.

> ‘TS 유틸리티 타입 > ReturnType’ 파트를 참고하세요.

```typescript

  type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

  function fn(num: number) {
    return num.toString();
  }

  const a: ReturnType<typeof fn> = 'Hello';

```

위 예제에서 <code>typeof fn</code>은 <code>(num: number) => string</code>으로 반환 타입은 <code>string</code>입니다. <br />
따라서 <code>R</code>은 <code>string</code>이고 역시 <code>infer</code> 키워드를 통해서 타입 추론이 가능하기 때문에 <code>R</code>을 반환합니다. <br />
즉, <code>string</code>을 반환합니다. <br />

<code>infer</code> 키워드에 대한 더 자세한 내용은 공식 문서의 [Type inference in conditional types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types) 파트를 참고하세요. <br />
문서 내용은 다음과 같이 간단히 정리했습니다. <br />

*  <code>infer</code> 키워드는 제약 조건 <code>extends</code>가 아닌 조건부 타입 <code>extends</code> 절에서만 사용 가능
*  <code>infer</code> 키워드는 같은 타입 변수를 여러 위치에서 사용 가능
  *  일반적인 공변성(co-variant) 위치에선 유니언 타입으로 추론
  *  함수 인수인 반공변성(contra-variant) 위치에선 인터섹션 타입으로 추론
*  여러 호출 시그니처(함수 오버로드)의 경우 마지막 시그니처에서 추론

> 공변성과 반공변성에 대한 자세한 내용은 다음 포스트를 참고하세요. <br />
> [TypeScript에서의 공변성과 반공변성 (strictFunctionTypes)](https://medium.com/@iamssen/typescript-%EC%97%90%EC%84%9C%EC%9D%98-%EA%B3%B5%EB%B3%80%EC%84%B1%EA%B3%BC-%EB%B0%98%EA%B3%B5%EB%B3%80%EC%84%B1-strictfunctiontypes-a82400e67f2) <br />

## 함수

기본적인 함수 사용에 대해선 위에서 살펴봤습니다. <br />
여기서는 타입스크립트 함수의 주요 특징들에 대해서 살펴봅시다. <br />

## this

함수를 다루는 데 있어 가장 중요한 내용 중 하나가 바로 <code>this</code>입니다. <br />
함수 내 <code>this</code>는 전역 객체를 참조하거나(sloppy mode), <code>undefined</code>(strict mode)가 되는 등 우리가 원하는 콘텍스트(context)를 잃고 다른 값이 되는 경우들이 있습니다. <br />

```typescript
  
  const obj = {
    a: 'Hello~',
    b: function () {
      console.log(this.a); // obj.a
      // Inner function
      function b() {
        console.log(this.a); // global.a
      }
    }
  };

```

특히 ‘호출하지 않는 메소드’를 사용하는 경우에 <code>this</code>로 인한 문제가 발생합니다. <br />
우선, 다음 예제를 살펴봅시다. <br />
객체 데이터 <code>obj</code>에서 <code>b</code> 메소드는 <code>a</code> 속성을 <code>this</code>를 통해 참조하고 있습니다. <br />

```typescript

  const obj = {
    a: 'Hello~',
    b: function () {
      console.log(this.a);
    }
  };

```

위 객체를 기준으로 아래 예제와 같이 ‘호출하지 않는 메소드’를 사용(할당)하는 경우, <code>this</code>가 유효한 콘텍스트를 잃어버리고 <code>a</code>를 참조할 수 없게 됩니다.

> 많은 경우 콜백 함수가 해당합니다.

```typescript
  
  obj.b(); // Hello~

  const b = obj.b;
  b(); // Cannot read property 'a' of undefined

  function someFn(cb: any) {
    cb();
  }
  someFn(obj.b); // Cannot read property 'a' of undefined

  setTimeout(obj.b, 100); // undefined

```

이런 상황에서 <code>this</code> 콘텍스트가 정상적으로 유지되어 <code>a</code> 속성을 참조할 수 있는 방법을 알아봅시다. <br />
 
첫 번째는 [bind 메소드](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)를 사용해 <code>this</code>를 직접 연결해 주는 방법입니다. <br />














































































