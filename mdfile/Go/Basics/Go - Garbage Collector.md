## 시작
말 그대로 쓰레기 청소부 라는 의미인데, Momory에 있는 쓰레기를 청소하는 것이다. <br />
메모리에 어떤 쓰레기가 쌓이는지 알아보자! <br />
변수는 여러 속성을 갖지만 가장 중요한 속성은 <code>변수는 메모리다.</code>라는 것이다. <br />
변수는 값을 담는 그릇인데 <br />
``` Go
  var a int
```
이런식으로 변수를 선언하게 되면 메모리에 이 그릇을 만들었다는 소리이고, 이 그릇이 있는 곳이 메모리 주소인데 그 메모리 주소를 변수 a가 나타내고 있는 것인데 <br />
이렇게 변수를 선언해서 메모리를 확보만 해놓고 쓰지 않게되고, 이러한 변수들이 많아지면 메모리만 차지하게 될 것이고, 결국에는 메모리가 부족해서 프로그램이 종료되는 상황에 이를 수 있다. <br />
이런걸 메모리에 쌓이는 쓰레기라 해서 **Momory Garbage**라고 한다. 이러한 **Momory Garbage**가 생기는 이유는 무엇일까? <br />

만약에 <br />
``` Go
  var p *int
  var a int
  p = &a
```
이렇게 변수를 선언 했을 때 p도 아무도 안쓰고, a도 아무도 안 쓸 때 a의 존재는 잊혀질 것이고, 아무도 참조하지 않는 공간이 된다. 이 것은 지울 수가 없다. <br />
그래서 이 공간이 **Garbage**로 변환되는 것이다. 사실 Go에서는 이런 경우가 생기지 않기 때문에 Go에서는 조금 어렵기 때문에 'C언어'에서 메모리 쓰레기가 어떻게 쌓이는지 알아보자.<br />

C언어에서는 변수를 위한 메모리를 두 가지로 구분할 수 있다. <br />
**스택 메모리**와 **힙 메모리**로 나뉘는데 이 스택과 힙은 자료 구조를 나타내는 것이다. 자료구조 중에 스텍이란 자료구조와 힙이라는 자료구조가 있다. <br />
이 메모리를 할당하는 형태가 **스택**으로 되어있어서 **스택 메모리**, **힙** 형태로 되어 있어서 **힙 메모리**라고 부르기도 하는데 <br />

이 둘이 뭐가 다르냐면 C언어 에서는 일반적인 변수선언이 있다. 가령 int형 a를 C에서 선언하면 이렇게 선언할 수 있다. <br />
``` C
  int a;
```
이렇게 일반적인 변수는 **스택 메모리**에서 할당이 된다. <br />

||
|------|
||
||
|a|

``` C
  int a;
  int b;
```

추가로 int 형 b를 선언하면 아래와 같이 쌓이는 구조이다. <br />
||
|------|
||
|b|
|a|

이런식으로 변수를 선언하면 스택 메모리를 사용하게 되는 것이고, 힙 메모리는 C언어에서는 힙을 프로그래머가 얼마만큼 사용하고 싶은지 할당 할 수 있다. <br />
그 함수가 [Malloc](https://tyeolrik.github.io/c/2017/02/01/1-dynamic-memory-allocation.md.html)이란 함수이다. <br />
**memory allocation**의 약자인데 **malloc**이란 함수를 써서 사이즈를 집어넣으면 그 사이즈에 해당하는 메모리를 힙 영역에서 할당을 하고, 그 주소를 반환한다. <br />

``` C
malloc(원하는 사이즈)
```
그래서 이 반환 주소는 여기서는 <code>viod *(포인터)</code>라고 하는데 그냥 포인터 형태로 반환 된다고 보면 된다. <br />
그러니까 메모리 주소 형태로 반환이 된다. <br />
그래서 메모리 할당받은 주소를 가지고 메모리를 사용하는 것이다. <br />
C언어에서는 메모리를 프로그래머가 접근할 수 있는 권한이 막강하기 때문에 메모리를 크게 할당 받아서 자기 마음대로 짤라 쓸 수가 있다. <br />
그래서 메모리 관리 할 때 자유도가 높다고 할 수 있다. (물론 자유가 높다고 해서 꼭 좋은건 아니지만)<Br />

``` C
p = malloc(100);
```

malloc으로 할당을 받았고 예를 들어 100byte의 메모리를 할당 받아서 p라는 포인터 변수에 저장했고, 이 메모리를 p가 가르키고 있게 될 것이고, <br />
할당받은 메모리는 c언어에서는 반드시 지워줘야 한다. <br />
그래서 free()라는 함수로 할당받은 메모리를 쓰다가 더 이상 쓸모가 없어지면 지워줘야 한다. <br />

``` C
p = malloc(100);
free(p)
```
C언어에서는 항상 쌍으로 발생을 해야한다. 프로그래머가 할당을 받았으면 반드시 지워줘야 된다. <br />
근데 버그라는 게 항상 존재한다. 반드시 할당을 받았으면 반드시 쓸모가 없어졌을 때 반드시 지워줘야 되는데 이걸 깜빡하거나 뭔가 버그 때문에 이걸 못 지워서 free()를 못했다하고 <br />
그리고 p값이 없어졌다해서 할당받은 메모리가 사라지지 않는다. 이거는 남아있는데 아무도 이 메모리를 참조 할 수도, 참조 하지도, 지울 수도 없다. <br />
그래서 이런 것들이 하나 둘 씩 쌓이면서 메모리에 쓰레기가 쌓이게 된다. <br />

이런 것을 메모리 릭이라고 해서 메모리가 새고 있다는 소리인데 나중엔 메모리가 부족해져서 프로그램이 종료되는 사태가 발생한다. <br />

조금 더 설명하자면 스택 메모리가 C언어에서는 어떻게 되냐면 스택 메모리가 변수 범위를 벗어나면 스택 메모리가 사라진다. <Br />

가령 예를 들고 
``` C
if(...) {
  int a;
  ...
}
```
if문이 있고, 중괄호가 열리고, a변수를 선언했고, 그 밑으로 무언가를 하면서 그 아래에 if문이 끝난다. 했을 때 a변수의 범위는 a가 속한 중괄호 까지이다. <br />
C언어에서는 이 범위를 벗어나면 a를 없애버리는데 <br />

``` C
if(...) {
  p = malloc(100)
  ...
}
```
여기서 포인터에 malloc으로 메모리를 100byte를 받았고 p라는 포인터형 변수를 위한 메모리를 스택에 만들텐데 그런데 여기서 free()를 하지 않고 if문을 벗어나 버리면 스택 변수를 지워버렸다 했을 때 <br />
p가 없어졌기 때문에 이 바깥에서는 p를 접근할 방법이 없다. <br />
그러면 이 malloc받은 메모리 주소를 가지고 있는 것이 없어진거고, 이 malloc을 받았던 주소는 아무도 모른다. <br />
바깥에서 free()를 하고 싶어도 할 수가 없게 되는 것이다. <br />

이런경우에 메모리 릭이 발생하는 흔한 경우라고 볼 수 있다. <br />
그래서 [메모리 릭(Memory leak)](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%88%84%EC%88%98)이라는 것은 버그이다. <br />
버그라는 이야기는 프로그래머가 잘 짜면 발생하지 않을 수 있는데 이게 굉장히 흔한 버그이고, 흔히 실수하는 버그이다. <br />
그래서 나온게 'Garbage Collector'라고 보면 된다. 그래서 사용자가 다 기억했다가 지우게 하지 말고, 어떤 로봇같은게 돌아다니면서 쓰레기들을 수집해서 지워주는 역할을 하자 해서 만들어진 것인데 <br />

Garbage Collector가 하는 일은 단순하다. 말 그대로 쓰레기 청소부인데 메모리 상에 빈 공간에 할당받고 아무것도 안하는 것들이 있는데 이것들을 GC가 돌아다니면서 이것들을 지워주는 역할을 한다. <br />

그럼 실질적으로 이걸 어떻게 하는지 알아보자 <br />
기본적으로는 쓸모가 없어지면 쓰레기인데 쓸모가 없다는 것은 <br />
``` Go
func add() {

  var a int
  a = 3

}
```
이렇게 했을 때 마찬가지로 a의 범위는 add()이 중괄호가 끝난 시점이다. 이 바깥에서는 a가 쓸모가 없기 때문에 a는 쓰레기가 된다. <br />
그래서 a를 GC가 없애주는 것인데 그럼 어떻게 하면 쓸모가 있는지 없는지 알 수 있을까? <br />
가장 기본적인 법은 [Reference Counter](https://ko.wikipedia.org/wiki/%EC%B0%B8%EC%A1%B0_%ED%9A%9F%EC%88%98_%EA%B3%84%EC%82%B0_%EB%B0%A9%EC%8B%9D)가 있는데 누가 이 것을 참조하고 있는 지, 몇번 참조하고 있는지 횟수를 저장하는 것이다. <br />

가령 예를 들어 <br />
``` Go
var a int
var p *
p = &a
a = 3
```
a변수와 포인터형 p변수가 있다고 했을 때 p는 a의 주소를가지고 있고, a값이 3이고, p값도 3이 되는데 이런 경우에 a가 나나태는 메모리는 참조 횟수가 몇일까? <br />
보면은 a자체가 참조하고 있기 때문에 기본적으로 횟수는 1이다. 근데 포인터 p가 a의 주소를 참조 하고 있어 a를 가리키고 있기 때문에 참조횟수가 2가 된다. <br />
그래서 이 때 a는 레퍼런스 카운트가 2인데 언제 쓸모 없어지는 순간이 되냐면 레퍼런스 카운트가 0이 되는 순간이다. <br />

그럼 아까 add함수를 다시보자! <br />
``` Go
func add() {

  var a int
  a = 3

}
```
여기서 a를 만들었다는 것은 메모리 상에 a를 위한 메모리가 만들어졌고, 이 메모리를 a가 가리키고 있기 때문에 참조횟수는 1이다. <Br />
그 다음 중괄호로 벗어나게 되면 a가 범위를 벗어나게 되니까 a변수가 없어지게 되고, 참조했던 부분이 끊어져 참조횟수가 0이 되어 버린다. <br />
그래서 GC가 이 것을 지우게 된다. (참조횟수가 0이니까) <br />

이번에는 int형 포인터를 반환하는 함수가 있다고 가정해보자 <br />
``` Go
func add() *int {

  var a int
  var p *int
  
  a = 3
  p = &a
  
  return p
}

v := add()
```

그리고 어딘가에서 add()를 호출하고 그 호출된 결과를 변수 v에 넣었다고 가정해보자. <br />
이 경우에 참조횟수가 어떻게 되는지 확인해보자 <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/97253994-c9619d00-1850-11eb-9705-380266e64173.png" width = 70%> </img></p>
처음에 a를 만들어서 a라는 메모리가 생기게 되고, a가 가리키게 된다. 여기서 a의 참조 횟수가 1이 된다. <br />
그 다음 p가 만들어져서 마찬가지로 p의 참조횟수는 1이 되고<br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/97254294-66243a80-1851-11eb-89d4-a253d96216dc.png" width = 70%> </img></p>
p의 값이 a의 주소기 때문에 a의 주소값이 들어 갈 것이고, 그러면 이것도 a를 가리키고 있기 때문에 참조횟수가 1이 되어 1+1해서(두 군데서 가리키고 있으니까) a의 참조횟수가 2가 된다. <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/97254783-7852a880-1852-11eb-8ee1-f0c79f1a7d7d.png" width = 70%> </img></p>
그 다음 return p를 하면서 중괄호로 빠져나가는데 a와 p가 사라지게 되지만 아직 p값은 return p를 해서 v로 들어가니까 메모리 상에 남아있게 된다. <br />
그러면 v라는 변수가 메모리에 생기게 될 것이고, 이 것이 add()의 결과 값인 p를 가지고 있으니까 p값이 복사가 돼서 결론적으로 v가 a의 주소값을 가리키게 되고 <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/97254967-e5fed480-1852-11eb-8e77-5231af76098b.png" width = 70%> </img></p>

그 다음 범위를 벗어나게 되어 p가 없어지게 되고, 참조횟수가 0이 되면서 p는 GC가 지워버리게 될 것인데 <br />
원래 a의 메모리 주소는 v가 참조하고 있는데 a가 참조한 거 없어지고, p가 참조한 게 없어지니까 a의 참조횟수는 1이 되기 때문에 그래서 a의 메모리 값은 사라지지 않게 된다. <br />

그래서 v도 1, a도 1이 되는데 리턴되는 순간에 바로 없어지는 것이 아니고, <code>v := add()</code>까지 끝나고 난 다음에 사라진다고 보면 된다. <br />
여기까지 레퍼런스 카운트 얘기였다.
