### 시작
P2P는 Peer To Peer방식이라 해서 클라이언트 끼리 직접적으로 연결하는 방식이다. <br  />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/96392946-9851ee80-11f8-11eb-8287-9f29c53b647e.png" width = 70%> </img></p>
보통 1:1에서는 클라이언트와 클라이언트가 연결하는 형태이며, 예를들어 5명이 연결하는 다대다 형태일 때 2가지로 나뉘는데 <br />
방장을 정해서 방장에게 커넥트하는 방식. 방장이 모든 커넥션을 가지고 있는 방식이 있고, <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/96393195-64c39400-11f9-11eb-8281-8909ca594401.png" width = 70%> </img></p>
다른 하나는 풀리 커넥션(Fully Connection)이라 해서 모두가 모두에게 커넥션 하는 방식이 있다. <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/96393389-ea474400-11f9-11eb-8848-a9eabcd93bab.png" width = 70%> </img></p>

각각 장단점이 있는데 방장을 정해서 방장에게 커넥트하는 방식은 장점이라고 보면 커넥션이 하나밖에 없으니까 하나만 관리하면 되고, 방장이 있기 때문에 4개의 커넥션을 관리하지만 <br />
각자의 입장에서는 하나만 관리하는 측면에서 봤을 때 각 클라이언트가 걸려야되는 커넥션 수가 적다는 장점이 있고, 방장이 어떤 심판 역할을 할 수 있다. <br />

이러한 장점이 있는 반면에 단점은 방장이 게임이 나가버리거나 커넥션이 끊어지는 경우 방이 폭파되는 상황이 생길 수 있다. <br />
이 때 남아있는 사람들 중에서 또 다른 방장을 뽑아서 다시 그 사람을 중심으로 바꾸는 방법이 있지만 이렇게 하면 상당히 복잡하다. <br />
그래서 방장이 나갔을 때의 처리가 복잡하다는 단점이 있다. <br />

풀리 커넥션(Fully Connection)방식은 각 클라이언트가 모두 다른 클라이언트에 대한 모든 커넥션을 가지고 있다. <br />
각 클라이언트가 관리해야 하는 커넥션 수가 많은 단점이 있지만 한명의 커넥션이 끊어진 경우 나머지 사람들과의 커넥션이 사라지지 않았기 때문에 전환이 빠르게 된다는 장점이 있다. <br />

두번째로 Relay서버를 이용하는 방식이 있다. <br />
Relay서버는 말 그대로 정해진 서버가 있고, 클라이언트들이 그 서버에 접속하는 방식이다. <br />
<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/96394156-4612cc80-11fc-11eb-9539-c6a5ccb801c2.png" width = 70%> </img></p>
어떻게 보면 P2P에서 방장을 뽑아서 방장에게 접속하는 방식하고 비슷하다 볼 수 있는데 이것은 서버에 접속하는 방식이기 때문에 방장이 언제든지 나가거나, 컴퓨터를 꺼서 접속을 끊어버릴 수 있지만 <br />
이것은 갑자기 연결이 끊어지거나 하는 일은 잘 일어나지 않는다는 장점이 있다. 이것도 마찬가지로 서버가 심판이 될 수 있는데 P2P 역시 방장이 심판이 되기 때문에 불공정한 판단을 할 수 있지만(해킹으로 인해) <br />
서버는 해킹될 위험이 적기 때문에 훨씬 더 공정하게 판단하여 진행 할 수 있다. <br />

하지만 서버가 죽어버렸을 때 게임이 아예 진행이 안되는 일이 발생 할 수 있다는 단점이 있다. <br />

중요한 건 P2P냐 Relay냐가 아니다. P2P에서 가장 큰 문제점이 있는데 그렇기 때문에 Relay서버를 사용하기도 한다. <br />
이 문제점에 대해 알아보려하는데 상당히 길기 때문에 차근차근 알아보도록 하겠다. <br />
이 것을 알기 위해 인터넷이 처음 만들어진 시발점을 알아야 한다. <br />
어떻게보면 다른길로 세는 걸로 보일 수 있지만 이것을 잘 알아야 왜 이런문제가 생겼는지 알 수 있다. <br />

소련과 미국이 냉전을 하는데 각각 핵 미사일을 만들어 놔서 각각 본토를 공격할 수 있게 됐다. <br />
관건은 상대방이 핵 미사일을 발사한 다음에(상대방의 핵 미사일이 우리의 땅에 날라오기 전에) 우리가 핵 미사일을 발사할 수 있느냐 없느냐가 문제인 것인데 <br />

예를 들어 소련이 미국에게 핵미사일을 발사했고, 미국까지 날라가는데 2시간이 걸린다고 가정해보자 <br /> 
이 핵미사일이 발사된 것을 감지하고, 미국 대통령이 우리도 쏘자고 결정을 했고, 미국에서 발사되는데까지 3시간이 걸린다고 쳐보자. <br />
상황이 이러면 미국은 지게 될 것이다. 대응사격도 못하고 다 죽어버리는 상황이 생긴다. 상황이 이러면 먼저 쏘는 나라가 승리하기 때문에 이것을 대응사격의 체제를 구축 하는게 관건이였다. <br />

다시 돌아와서 소련이 미국에게 핵미사일을 발사했고, 미국까지 날라가는데 2시간이 걸린다고 했을 때 미국이 그것을 감지했고, 쏘자고 결정해서 발사하는데 걸리는 시간이 10분이라고 쳐보자. <br />
이 상황이 되면 아무도 미사일을 쏠 수 없을 것이다. <br /> 
왜냐하면 내가 쐈다해서 이긴다는 보장이 없고, 내가 쏘면 상대방도 쏘기 때문에 그 미사일이 땅에 닿기전에 쏴서 서로 같이 죽는 시나리오가 생긴다. <br />
그래서 이것을 대응사격의 체제를 구축 하는게 관건이였는데 이 시스템을 만들려면 백악관부터 시작해서 미사일 사일로까지 다이렉트로 연결되어 있다면 빨리 가겠지만 <br />
끊어지거나, 스파이가 침입해서 이 연결을 끊어버릴 수 있어서 한 가지에 의존 할 수 없다. <br />
그래서 여러 네트워크를 만들어놓고, 이것들이 서로를 잘 파악하고 있고, 미사일 발사 명령이 내려졌을 때 네트워크 경로를 찾아서 그 패킷을 전달하는 시스템이 필요했다. <Br />
그래서 이런 시스템을 구축하기 위해 육군에서 발주한 것이 '인터넷(Internet)'이였다. <br />

그래서 이것이 처음 나왔을 때 군사 목적으로 나왔지, 현재처럼 지구상에 있는 모든 컴퓨터가 다 인터넷을 사용할 것이라고 예측해서 만든것이 아니다. <br />

그래서 IPv4라는 인터넷 프로토콜을 만들었는데 숫자 4개로 컴퓨터의 주소를 쓰자고 정했다. <br />
초창기 군사목적으로 쓰였을 때는 충분히 많이 표현할 수 있었기 때문에 문제가 없었다. <br />
그런데 전 세계의 컴퓨터를 할당하기엔 IP가 턱없이 부족했다. <br />
그래서 나온게 IPv6인데 기존에 IPv4가 32bit로 표현했다면 이것은 128bit로 표현했다. <br />
그런데 아직 IPv4로도 잘 쓸 수 있는 기술이 나와서 여전히 IPv6가 아닌 IPv4를 사용하고 있다. <br />
이 기술이 IP Mapping이다. 모든 컴퓨터에 고정 IP를 할당할 수 없다. 컴퓨터가 너무 많아졌고, ip를 다 정할 수 없다. <br />

<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/96421304-95272480-1231-11eb-9365-e323086aead3.png" width = 70%> </img></p>
그래서 맨 앞에 컴퓨터 한 대만 고정IP를 정해놓고 모든 패킷을 얘가 받아서 분배를 해준다. <br />
그래서 그 안에 있는 컴퓨터들은 고정IP가 있을 필요가 없고, 맨 앞에 있는 컴퓨터가 지정해주는 번호만 알고 있으면 되는 것이다. <br />
기본적으로 ICP나 UDP와 같은 인터넷 프로토콜은 IP기반으로 돌아가기 때문에 맨 앞에 있는 컴퓨터가 그 안에 있는 컴퓨터들에게 IP를 할당 해준다고 생각하면 된다. <br />
가짜IP를 할당해준다. <br/>
예를 들어 내가 24.55.7.6이라는 고정IP를 가지고 있다 쳐보자. 그런데 내 안에 있는, 나에게 등록되어 있는 컴퓨터들은 겹치지 않는 아무 숫자만 가지고 있으면 된다. <br />
127.4.1.1이라던지, 7.7.75.2라던지..  그래서 나한테 접속할 때 그 컴퓨터에게 아무도 쓰고있지 않은 IP주소만 할당해주고, 내가 그것을 알고 있으면 된다. <br />

<p align = "center"> <img src = "https://user-images.githubusercontent.com/33046341/96398684-64ca9080-1207-11eb-9b14-a06ea2874fb2.png" width = 70%> </img></p>
여기서 자세히 보아야 할게 맨 앞에 받아주는 컴퓨터를 '게이트웨이'로 하고 고정IP가 28.1.2.3이라고 하고, 그 안에 등록되어 있는 컴퓨터들이 있으며, <br />
그 IP들이 서로 겹치지 않고, 편의상 1씩 증가한다고 가정해보자 <br />
패킷을 A에게 보내고 싶을 때 앞에 게이트웨이에 보내는 데 고정IP인 28.1.2.3로 가는데 A의 IP를 써서 보낼 수 없다.(게이트웨이 IP가 아니기 때문에 다른 곳으로 가게 된다.) <br />
우선 게이트웨이에 가야하는데 어떻게 보내야 A에게 전달 되는지 보내는 사람 입장에서는 알 수 없다. <br />
게이트웨이가 아래의 컴퓨터들의 IP를 감추고 있는 역할(Hide)을 하기 때문에 바깥에서는 A의 ip가 몇번인지 알 수가 없다. <br />
그래서 패킷이 들어가지 못하고 나오기만 가능하다. <br />

요즘의 상황에서는 앞에있는 게이트웨이가 언제나있다고 생각하면 되는데 NAT장비인 공유기가 이런 역할을 한다고 생각하면 된다. <br />
각자 어떤 클라이언트에게 보내고 싶지만 그 클라이언트의 고정IP가 없기 때문에 IP를 정확히 알 수도 없고, 어떤 IP로 보내야 할 지 서로 모른다. <br />
그래서 P2P통신 자체가 안되는 상황이 발생한다. <br />
이런 문제가 있기 때문에 P2P 자체가 불가능하냐?고 물어볼 수 있는데 그것도 아니다. <br /> 
이런 문제를 극복하기 위해서 홀펀칭(Hole Punching)이라는 기술이 나온다. 말 그대로 구멍을 뚫는다는 의미이다. <br />

각자의 Peer들이 어떤 NAT장비같이 IP를 Hide시켜주는 것 밑에 들어가 있어서 고정되어 있는 IP를 받는 클라이언트는 거의 없다고 보면 된다. <br />
그렇기 때문에 백도어 같이 하나의 구멍을 뚫어주어서 그것을 통해 패킷을 주고받는 상황을 만들어주는데, 이것을 홀펀칭이라고 한다. <br />
